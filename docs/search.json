[{"path":"https://fbertran.github.io/SelectBoost.beta/articles/selectboost-algorithms.html","id":"motivation","dir":"Articles","previous_headings":"","what":"Motivation","title":"SelectBoost.beta algorithms","text":"SelectBoost.beta re-uses correlated-resampling machinery introduced original SelectBoost package combines Beta-regression selectors. vignette summarises main routines presents pseudo-code internal logic. goal make easy re-implement extend algorithms contexts.","code":""},{"path":"https://fbertran.github.io/SelectBoost.beta/articles/selectboost-algorithms.html","id":"building-blocks","dir":"Articles","previous_headings":"","what":"Building blocks","title":"SelectBoost.beta algorithms","text":"following helpers expose canonical SelectBoost stages. sb_normalize() centres ℓ2\\ell_2-normalises design matrix columns. sb_compute_corr() computes correlation (user-supplied association) matrix normalised design. sb_group_variables() converts correlation matrix groups highly associated predictors given threshold c0c_0. sb_resample_groups() regenerates correlated predictors group drawing multivariate normal approximation re-normalising. sb_apply_selector_manual() applies selector resampled design collects resulting coefficient vectors. sb_selection_frequency() converts matrix coefficients selection frequencies respecting selector’s coefficient convention.","code":""},{"path":"https://fbertran.github.io/SelectBoost.beta/articles/selectboost-algorithms.html","id":"pseudo-code-manual-workflow","dir":"Articles","previous_headings":"","what":"Pseudo-code: manual workflow","title":"SelectBoost.beta algorithms","text":"manual SelectBoost workflow follows steps regardless base selector. Pseudo-code producing selection frequencies single threshold given . practice sb_resample_groups() preserves singletons untouched. groups two predictors receive correlated draws.","code":"Procedure ManualSelectBoost(X, Y, selector, c0, B):   1. X_norm <- sb_normalize(X)   2. Corr <- sb_compute_corr(X_norm)   3. Groups <- sb_group_variables(Corr, c0)   4. Resamples <- sb_resample_groups(X_norm, Groups, B)   5. CoefMatrix <- sb_apply_selector_manual(X_norm, Resamples, Y, selector)   6. Frequencies <- sb_selection_frequency(CoefMatrix, version = \"glmnet\")   7. Return Frequencies"},{"path":"https://fbertran.github.io/SelectBoost.beta/articles/selectboost-algorithms.html","id":"pseudo-code-correlation-grid-driver","dir":"Articles","previous_headings":"","what":"Pseudo-code: correlation grid driver","title":"SelectBoost.beta algorithms","text":"sb_beta() extends manual workflow iterating grid correlation thresholds. following pseudo-code matches behaviour exported function. selector argument can function returning numeric vector coefficients optional names. version = \"glmnet\", first entry interpreted intercept excluded selection frequencies. squeezing step enforces usual SelectBoost transformation pushes responses inside (0, 1). Keep enabled unless already pre-processed outcome; otherwise zero one values cause selectors abort.","code":"Algorithm sb_beta(X, Y, selector, B, step.num, steps.seq, version, squeeze):   1. If squeeze, transform Y into the open unit interval.   2. X_norm <- sb_normalize(X)   3. Corr <- sb_compute_corr(X_norm)   4. Grid <- {1} ∪ .sb_c0_sequence(Corr, step.num, steps.seq) ∪ {0}   5. For each c0 in Grid:        a. Groups <- sb_group_variables(Corr, c0)        b. If every group has size 1:             i. CoefMatrix <- selector(X_norm, Y)           Else:             i. Resamples <- sb_resample_groups(X_norm, Groups, B)            ii. For each design in Resamples:                   - CoefMatrix[, b] <- selector(design, Y)        c. Freq[c0, ] <- sb_selection_frequency(CoefMatrix, version)   6. Attach attributes (B, selector, c0 sequence) and return Freq"},{"path":"https://fbertran.github.io/SelectBoost.beta/articles/selectboost-algorithms.html","id":"extending-the-algorithms","dir":"Articles","previous_headings":"","what":"Extending the algorithms","title":"SelectBoost.beta algorithms","text":"modular helpers designed recomposed. example, possible plug custom grouping routine calling sb_resample_groups() supply selector implements cross-validation penalisation strategies. helper relies basic R primitives, pseudo-code translates readily languages.","code":""},{"path":"https://fbertran.github.io/SelectBoost.beta/articles/selectboost-algorithms.html","id":"conference-communications","dir":"Articles","previous_headings":"","what":"Conference communications","title":"SelectBoost.beta algorithms","text":"SelectBoost4Beta concepts described showcased Frédéric Bertrand Myriam Maumy 2023 : Joint Statistical Meetings 2023 (Toronto, Canada): “Improving variable selection Beta regression models using correlated resampling”. BioC2023 (Boston, USA): “SelectBoost4Beta: Improving variable selection Beta regression models”. communications detailed correlation-aware resampling strengthens variable selection performance Beta regression strong predictor dependencies.","code":""},{"path":"https://fbertran.github.io/SelectBoost.beta/articles/selectboost-beta.html","id":"overview","dir":"Articles","previous_headings":"","what":"Overview","title":"SelectBoost for Beta regression","text":"new sb_beta() helper glues beta-regression selectors provided package SelectBoost-style correlated-resampling loop implemented directly SelectBoost.beta. takes care squeezing response inside open unit interval (unless squeeze = FALSE) tagging output selector used. vignette walks two complementary perspectives: Reconstructing SelectBoost workflow step step betareg_step_aic() highlight correlated resampling happens. Calling sb_beta() obtain result single function call. Throughout examples rely built-simulator generate correlated design matrices handful truly associated predictors.","code":"sim <- simulation_DATA.beta(   n = 150, p = 6, s = 3, beta_size = c(1, -0.8, 0.6),   corr = \"ar1\", rho = 0.25,   mechanism = \"jitter\" ) str(sim$X) #>  num [1:150, 1:6] -0.123 1.635 1.428 -0.508 -0.243 ... #>  - attr(*, \"dimnames\")=List of 2 #>   ..$ : NULL #>   ..$ : chr [1:6] \"x1\" \"x2\" \"x3\" \"x4\" ... summary(sim$Y) #>    Min. 1st Qu.  Median    Mean 3rd Qu.    Max.  #> 0.04934 0.25725 0.49003 0.48969 0.70233 0.99998"},{"path":"https://fbertran.github.io/SelectBoost.beta/articles/selectboost-beta.html","id":"manual-selectboost-workflow-with-beta-selectors","dir":"Articles","previous_headings":"","what":"Manual SelectBoost workflow with beta selectors","title":"SelectBoost for Beta regression","text":"classic SelectBoost algorithm first normalises design matrix, computes pairwise correlations, groups variables chosen threshold finally resamples predictors applying selector. stages available directly SelectBoost.beta. element X_draws stores correlated copy normalised design. Feeding matrices sb_apply_selector_manual() together beta-regression selector yields coefficient estimates every resampled data set. Finally, sb_selection_frequency() helper counts often variable appears non-zero coefficient across replicates. betareg_step_aic() returns glmnet-style coefficient vector (intercept plus predictors), set version = \"glmnet\" computing selection frequencies. manual exercise confirms correlated resampling loop original SelectBoost package plugs seamlessly beta selectors shipped SelectBoost.beta.","code":"# Normalise the predictors (centre + L2 scale) X_norm <- sb_normalize(sim$X)  # Compute correlations corr_mat <- sb_compute_corr(X_norm)  # Group variables whose absolute correlation exceeds 0.6 raw_groups <- sb_group_variables(corr_mat, c0 = 0.6)  # Draw eight correlated replicas for the grouped variables X_draws <- sb_resample_groups(X_norm, raw_groups, B = 8, seed = 11)  dim(X_draws[[1]]) #> [1] 150   6 coef_path <- sb_apply_selector_manual(   X_norm, X_draws, sim$Y, selector = betareg_step_aic )  dim(coef_path) #> [1] 8 8 coef_path[, 1:3] #>                        sim1        sim2        sim3 #> (Intercept)     -0.03588528 -0.03588528 -0.03588528 #> x1              11.34931343 11.34931343 11.34931343 #> x2              -8.95724666 -8.95724666 -8.95724666 #> x3               7.17554325  7.17554325  7.17554325 #> x4               0.00000000  0.00000000  0.00000000 #> x5               0.87055660  0.87055660  0.87055660 #> x6               0.00000000  0.00000000  0.00000000 #> phi|(Intercept)  2.95165950  2.95165950  2.95165950 sel_freq <- sb_selection_frequency(coef_path, version = \"glmnet\") sel_freq #>              x1              x2              x3              x4              x5  #>               1               1               1               0               1  #>              x6 phi|(Intercept)  #>               0               1"},{"path":"https://fbertran.github.io/SelectBoost.beta/articles/selectboost-beta.html","id":"running-the-entire-loop-with-sb_beta","dir":"Articles","previous_headings":"","what":"Running the entire loop with sb_beta()","title":"SelectBoost for Beta regression","text":"sb_beta() wrapper performs steps internally exposing arguments relevant beta regression. default uses betareg_step_aic() base selector, exported functions (\"betareg_step_bic\", betareg_glmnet, etc.) can passed either name function. resulting matrix comes several attributes document frequencies generated. attr(sb, \"c0.seq\") returns correlation threshold grid, attr(sb, \"B\") stores number correlated resamples per threshold, attr(sb, \"interval\") highlights whether interval sampling activated, attr(sb, \"resample_diagnostics\") keeps summary statistics cached surrogate draws. metadata mirror legacy SelectBoost beta implementation now documented ?sb_beta(). Changing selector simply matter passing different routine. call uses GAMLSS-based elastic-net variant asks sb_beta() pass choose = \"bic\" underlying betareg_glmnet() implementation. wrapper always builds correlated resamples, results directly comparable across selectors long adopt glmnet-style coefficient convention. makes straightforward run stability analyses interval responses pairing sb_beta() convenience wrapper sb_beta_interval() (lower-level fastboost_interval()) compare several beta selectors exact resampled design matrices.","code":"sb <- sb_beta(   sim$X, sim$Y,   B = 60,   step.num = 0.5,   steps.seq = c(0.9, 0.7, 0.5) )  class(sb) #> [1] \"sb_beta\" \"matrix\"  \"array\" attr(sb, \"selector\") #> [1] \"betareg_step_aic\" rownames(sb) #> [1] \"c0 = 1.000\" \"c0 = 0.900\" \"c0 = 0.700\" \"c0 = 0.500\" \"c0 = 0.000\" round(sb, 3) #> SelectBoost beta selection frequencies #> Selector: betareg_step_aic #> Resamples per threshold: 60 #> Interval mode: none #> c0 grid: 1.0, 0.9, 0.7, 0.5, 0.0 #> Inner thresholds: 0.9, 0.7, 0.5 #>               x1    x2    x3    x4   x5    x6 phi|(Intercept) #> c0 = 1.000 1.000 1.000 1.000 0.000 1.00 0.000               1 #> c0 = 0.900 1.000 1.000 1.000 0.000 1.00 0.000               1 #> c0 = 0.700 1.000 1.000 1.000 0.000 1.00 0.000               1 #> c0 = 0.500 1.000 1.000 1.000 0.000 1.00 0.000               1 #> c0 = 0.000 0.117 0.133 0.117 0.167 0.15 0.167               1 #> attr(,\"c0.seq\") #> [1] 1.0 0.9 0.7 0.5 0.0 #> attr(,\"steps.seq\") #> [1] 0.9 0.7 0.5 #> attr(,\"B\") #> [1] 60 #> attr(,\"selector\") #> [1] \"betareg_step_aic\" #> attr(,\"resample_diagnostics\") #> attr(,\"resample_diagnostics\")$`c0 = 1.000` #> [1] group                   size                    regenerated             #> [4] cached                  mean_abs_corr_orig      mean_abs_corr_surrogate #> [7] mean_abs_corr_cross     #> <0 rows> (or 0-length row.names) #>  #> attr(,\"resample_diagnostics\")$`c0 = 0.900` #> [1] group                   size                    regenerated             #> [4] cached                  mean_abs_corr_orig      mean_abs_corr_surrogate #> [7] mean_abs_corr_cross     #> <0 rows> (or 0-length row.names) #>  #> attr(,\"resample_diagnostics\")$`c0 = 0.700` #> [1] group                   size                    regenerated             #> [4] cached                  mean_abs_corr_orig      mean_abs_corr_surrogate #> [7] mean_abs_corr_cross     #> <0 rows> (or 0-length row.names) #>  #> attr(,\"resample_diagnostics\")$`c0 = 0.500` #> [1] group                   size                    regenerated             #> [4] cached                  mean_abs_corr_orig      mean_abs_corr_surrogate #> [7] mean_abs_corr_cross     #> <0 rows> (or 0-length row.names) #>  #> attr(,\"resample_diagnostics\")$`c0 = 0.000` #>               group size regenerated cached mean_abs_corr_orig #> 1 x1,x2,x3,x4,x5,x6    6          60  FALSE          0.1189262 #>   mean_abs_corr_surrogate mean_abs_corr_cross #> 1               0.1403387          0.05889867 #>  #> attr(,\"interval\") #> [1] \"none\" sb_enet <- sb_beta(   sim$X, sim$Y,   selector = betareg_glmnet,   B = 60,   step.num = 0.5,   version = \"glmnet\",   choose = \"bic\",   prestandardize = TRUE )  attr(sb_enet, \"selector\") #> [1] \"betareg_glmnet\" colMeans(sb_enet) #>         x1         x2         x3         x4         x5         x6  #> 0.33888889 0.34444444 0.33888889 0.35555556 0.34444444 0.01111111"},{"path":"https://fbertran.github.io/SelectBoost.beta/articles/selectboost-beta.html","id":"conference-communications","dir":"Articles","previous_headings":"","what":"Conference communications","title":"SelectBoost for Beta regression","text":"SelectBoost4Beta workflow correlated resampling foundations presented Frédéric Bertrand Myriam Maumy 2023 two conferences: Joint Statistical Meetings 2023 (Toronto, Canada) — “Improving variable selection Beta regression models using correlated resampling”. BioC2023 (Boston, USA) — “SelectBoost4Beta: Improving variable selection Beta regression models”. communications emphasised leveraging correlation-aware resampling improves recall precision variable selection high-dimensional Beta regression settings.","code":""},{"path":"https://fbertran.github.io/SelectBoost.beta/articles/selectboost-cran.html","id":"introduction","dir":"Articles","previous_headings":"","what":"Introduction","title":"Getting started with SelectBoost.beta","text":"vignette provides CRAN-friendly tour SelectBoost.beta workflow. simulates reproducible beta-regression data set, runs high-level sb_beta() driver, shows interpret stability matrix returned algorithm. code self-contained executes quickly default knitr settings.","code":""},{"path":"https://fbertran.github.io/SelectBoost.beta/articles/selectboost-cran.html","id":"simulated-data","dir":"Articles","previous_headings":"","what":"Simulated data","title":"Getting started with SelectBoost.beta","text":"use built-simulation_DATA.beta() helper generate correlated design three truly associated predictors. response lives (0, 1) already compatible beta-regression selectors.","code":"sim <- simulation_DATA.beta(n = 120, p = 6, s = 3, rho = 0.35,   beta_size = c(1.1, -0.9, 0.7)) str(sim$X) #>  num [1:120, 1:6] 0.982 0.469 -0.108 -0.213 1.158 ... #>  - attr(*, \"dimnames\")=List of 2 #>   ..$ : NULL #>   ..$ : chr [1:6] \"x1\" \"x2\" \"x3\" \"x4\" ... summary(sim$Y) #>      Min.   1st Qu.    Median      Mean   3rd Qu.      Max.  #> 6.685e-05 1.907e-01 5.068e-01 4.763e-01 7.551e-01 9.862e-01"},{"path":"https://fbertran.github.io/SelectBoost.beta/articles/selectboost-cran.html","id":"running-sb_beta","dir":"Articles","previous_headings":"","what":"Running sb_beta()","title":"Getting started with SelectBoost.beta","text":"sb_beta() wrapper orchestrates full SelectBoost loop: normalises design matrix, groups correlated predictors, regenerates surrogate designs, records selection frequencies threshold. returned matrix one row per correlation threshold. Attributes attached matrix document fit produced: Use summary() obtain per-threshold summaries autoplot.sb_beta() (ggplot2 available) visualise stability matrix.  frequency values range 0 1 report often predictor received non-zero coefficient across correlated replicates. High values signal stable selections. data contain zeros ones, keep squeeze = TRUE (default) algorithm applies standard SelectBoost transformation fitting selectors.","code":"sb <- sb_beta(sim$X, sim$Y, B = 40, step.num = 0.4, seed = 99) sb #> SelectBoost beta selection frequencies #> Selector: betareg_step_aic #> Resamples per threshold: 40 #> Interval mode: none #> c0 grid: 1.000, 0.124, 0.078, 0.000 #> Inner thresholds: 0.124, 0.078 #>               x1    x2    x3    x4   x5    x6 phi|(Intercept) #> c0 = 1.000 1.000 1.000 1.000 0.000 0.00 0.000               1 #> c0 = 0.124 0.125 0.125 1.000 0.050 0.15 0.125               1 #> c0 = 0.078 0.100 0.075 0.200 0.050 0.10 0.050               1 #> c0 = 0.000 0.150 0.200 0.175 0.225 0.10 0.175               1 #> attr(,\"c0.seq\") #> [1] 1.0000000 0.1244760 0.0780104 0.0000000 #> attr(,\"steps.seq\") #> [1] 0.1244760 0.0780104 #> attr(,\"B\") #> [1] 40 #> attr(,\"selector\") #> [1] \"betareg_step_aic\" #> attr(,\"resample_diagnostics\") #> attr(,\"resample_diagnostics\")$`c0 = 1.000` #> [1] group                   size                    regenerated             #> [4] cached                  mean_abs_corr_orig      mean_abs_corr_surrogate #> [7] mean_abs_corr_cross     #> <0 rows> (or 0-length row.names) #>  #> attr(,\"resample_diagnostics\")$`c0 = 0.124` #>      group size regenerated cached mean_abs_corr_orig mean_abs_corr_surrogate #> 1 x1,x4,x5    3          40  FALSE          0.1127816              0.12452284 #> 2    x2,x6    2          40  FALSE          0.1244760              0.09934462 #> 3 x1,x4,x6    3          40  FALSE          0.1396964              0.14968931 #> 4    x1,x5    2          40  FALSE          0.1401757              0.15635997 #> 5 x2,x4,x6    3          40  FALSE          0.1374098              0.15700612 #>   mean_abs_corr_cross #> 1          0.08495110 #> 2          0.06325177 #> 3          0.06968686 #> 4          0.06534756 #> 5          0.06941150 #>  #> attr(,\"resample_diagnostics\")$`c0 = 0.078` #>            group size regenerated cached mean_abs_corr_orig #> 1 x1,x3,x4,x5,x6    5          40  FALSE         0.09727572 #> 2    x2,x3,x4,x6    4          40  FALSE         0.10188328 #> 3 x1,x2,x3,x5,x6    5          40  FALSE         0.08631999 #> 4    x1,x2,x4,x6    4          40  FALSE         0.11819411 #> 5       x1,x3,x5    3          40  FALSE         0.10711418 #> 6 x1,x2,x3,x4,x6    5          40  FALSE         0.10113912 #>   mean_abs_corr_surrogate mean_abs_corr_cross #> 1               0.1112624          0.07500762 #> 2               0.1142810          0.06898823 #> 3               0.1085051          0.07026698 #> 4               0.1219593          0.07188999 #> 5               0.1167484          0.07259936 #> 6               0.1154673          0.07398801 #>  #> attr(,\"resample_diagnostics\")$`c0 = 0.000` #>               group size regenerated cached mean_abs_corr_orig #> 1 x1,x2,x3,x4,x5,x6    6          40  FALSE         0.09172931 #>   mean_abs_corr_surrogate mean_abs_corr_cross #> 1               0.1087976          0.07717904 #>  #> attr(,\"interval\") #> [1] \"none\" attr(sb, \"c0.seq\") #> [1] 1.0000000 0.1244760 0.0780104 0.0000000 attr(sb, \"B\") #> [1] 40 attr(sb, \"interval\") #> [1] \"none\" summary(sb) #> SelectBoost beta summary #> Selector: betareg_step_aic #> Resamples per threshold: 40 #> Interval mode: none #> c0 grid: 1.000, 0.124, 0.078, 0.000 #> Inner thresholds: 0.124, 0.078 #> Top rows: #>       c0        variable frequency #> 1  1.000              x1     1.000 #> 2  1.000              x2     0.125 #> 3  1.000              x3     0.100 #> 4  1.000              x4     0.150 #> 5  1.000              x5     1.000 #> 6  1.000              x6     0.125 #> 7  1.000 phi|(Intercept)     0.075 #> 8  0.124              x1     0.200 #> 9  0.124              x2     1.000 #> 10 0.124              x3     1.000 if (requireNamespace(\"ggplot2\", quietly = TRUE)) {   autoplot.sb_beta(sb) }"},{"path":"https://fbertran.github.io/SelectBoost.beta/articles/selectboost-cran.html","id":"comparing-selectors","dir":"Articles","previous_headings":"","what":"Comparing selectors","title":"Getting started with SelectBoost.beta","text":"wish benchmark multiple selector families, compare_selectors_single() helper runs data set returns raw coefficients tidy summary table. Column names briefly shortened internally satisfy selector mapped back outputs. Bootstrap tallies add stability perspective. freq column table measures proportion resamples variable selected; values close 1 indicate consistent discoveries. Merge views compare_table() use plot_compare_coeff() plot_compare_freq() quick diagnostics.","code":"single <- compare_selectors_single(sim$X, sim$Y, include_enet = FALSE) head(single$table) #>    selector variable       coef selected #> x1      AIC       x1  1.0590158     TRUE #> x2      AIC       x2 -0.8855152     TRUE #> x3      AIC       x3  0.7277844     TRUE #> x4      AIC       x4  0.0000000    FALSE #> x5      AIC       x5  0.0000000    FALSE #> x6      AIC       x6  0.0000000    FALSE freq <- compare_selectors_bootstrap(sim$X, sim$Y, B = 20, include_enet = FALSE,   seed = 99) #> Warning in betareg.fit(X, Y, Z, weights, offset, link, link.phi, type, control, #> : no valid starting value for precision parameter found, using 1 instead #> Warning in betareg.fit(X, Y, Z, weights, offset, link, link.phi, type, control, #> : no valid starting value for precision parameter found, using 1 instead #> Warning in betareg.fit(X, Y, Z, weights, offset, link, link.phi, type, control, #> : no valid starting value for precision parameter found, using 1 instead #> Warning in betareg.fit(X, Y, Z, weights, offset, link, link.phi, type, control, #> : no valid starting value for precision parameter found, using 1 instead #> Warning in betareg.fit(X, Y, Z, weights, offset, link, link.phi, type, control, #> : no valid starting value for precision parameter found, using 1 instead #> Warning in betareg.fit(X, Y, Z, weights, offset, link, link.phi, type, control, #> : no valid starting value for precision parameter found, using 1 instead #> Warning in betareg.fit(X, Y, Z, weights, offset, link, link.phi, type, control, #> : no valid starting value for precision parameter found, using 1 instead #> Warning in betareg.fit(X, Y, Z, weights, offset, link, link.phi, type, control, #> : no valid starting value for precision parameter found, using 1 instead #> Warning in betareg.fit(X, Y, Z, weights, offset, link, link.phi, type, control, #> : no valid starting value for precision parameter found, using 1 instead #> Warning in betareg.fit(X, Y, Z, weights, offset, link, link.phi, type, control, #> : no valid starting value for precision parameter found, using 1 instead #> Warning in betareg.fit(X, Y, Z, weights, offset, link, link.phi, type, control, #> : no valid starting value for precision parameter found, using 1 instead #> Warning in betareg.fit(X, Y, Z, weights, offset, link, link.phi, type, control, #> : no valid starting value for precision parameter found, using 1 instead #> Warning in betareg.fit(X, Y, Z, weights, offset, link, link.phi, type, control, #> : no valid starting value for precision parameter found, using 1 instead #> Warning in betareg.fit(X, Y, Z, weights, offset, link, link.phi, type, control, #> : no valid starting value for precision parameter found, using 1 instead #> Warning in betareg.fit(X, Y, Z, weights, offset, link, link.phi, type, control, #> : no valid starting value for precision parameter found, using 1 instead #> Warning in betareg.fit(X, Y, Z, weights, offset, link, link.phi, type, control, #> : no valid starting value for precision parameter found, using 1 instead #> Warning in betareg.fit(X, Y, Z, weights, offset, link, link.phi, type, control, #> : no valid starting value for precision parameter found, using 1 instead #> Warning in betareg.fit(X, Y, Z, weights, offset, link, link.phi, type, control, #> : no valid starting value for precision parameter found, using 1 instead #> Warning in betareg.fit(X, Y, Z, weights, offset, link, link.phi, type, control, #> : no valid starting value for precision parameter found, using 1 instead #> Warning in betareg.fit(X, Y, Z, weights, offset, link, link.phi, type, control, #> : no valid starting value for precision parameter found, using 1 instead #> Warning in betareg.fit(X, Y, Z, weights, offset, link, link.phi, type, control, #> : no valid starting value for precision parameter found, using 1 instead #> Warning in betareg.fit(X, Y, Z, weights, offset, link, link.phi, type, control, #> : no valid starting value for precision parameter found, using 1 instead #> Warning in betareg.fit(X, Y, Z, weights, offset, link, link.phi, type, control, #> : no valid starting value for precision parameter found, using 1 instead #> Warning in betareg.fit(X, Y, Z, weights, offset, link, link.phi, type, control, #> : no valid starting value for precision parameter found, using 1 instead #> Warning in betareg.fit(X, Y, Z, weights, offset, link, link.phi, type, control, #> : no valid starting value for precision parameter found, using 1 instead #> Warning in betareg.fit(X, Y, Z, weights, offset, link, link.phi, type, control, #> : no valid starting value for precision parameter found, using 1 instead #> Warning in betareg.fit(X, Y, Z, weights, offset, link, link.phi, type, control, #> : no valid starting value for precision parameter found, using 1 instead #> Warning in betareg.fit(X, Y, Z, weights, offset, link, link.phi, type, control, #> : no valid starting value for precision parameter found, using 1 instead #> Warning in betareg.fit(X, Y, Z, weights, offset, link, link.phi, type, control, #> : no valid starting value for precision parameter found, using 1 instead #> Warning in betareg.fit(X, Y, Z, weights, offset, link, link.phi, type, control, #> : no valid starting value for precision parameter found, using 1 instead #> Warning in betareg.fit(X, Y, Z, weights, offset, link, link.phi, type, control, #> : no valid starting value for precision parameter found, using 1 instead #> Warning in betareg.fit(X, Y, Z, weights, offset, link, link.phi, type, control, #> : no valid starting value for precision parameter found, using 1 instead #> Warning in betareg.fit(X, Y, Z, weights, offset, link, link.phi, type, control, #> : no valid starting value for precision parameter found, using 1 instead #> Warning in betareg.fit(X, Y, Z, weights, offset, link, link.phi, type, control, #> : no valid starting value for precision parameter found, using 1 instead #> Warning in betareg.fit(X, Y, Z, weights, offset, link, link.phi, type, control, #> : no valid starting value for precision parameter found, using 1 instead #> Warning in betareg.fit(X, Y, Z, weights, offset, link, link.phi, type, control, #> : no valid starting value for precision parameter found, using 1 instead #> Warning in betareg.fit(X, Y, Z, weights, offset, link, link.phi, type, control, #> : no valid starting value for precision parameter found, using 1 instead #> Warning in betareg.fit(X, Y, Z, weights, offset, link, link.phi, type, control, #> : no valid starting value for precision parameter found, using 1 instead #> Warning in betareg.fit(X, Y, Z, weights, offset, link, link.phi, type, control, #> : no valid starting value for precision parameter found, using 1 instead #> Warning in betareg.fit(X, Y, Z, weights, offset, link, link.phi, type, control, #> : no valid starting value for precision parameter found, using 1 instead #> Warning in betareg.fit(X, Y, Z, weights, offset, link, link.phi, type, control, #> : no valid starting value for precision parameter found, using 1 instead #> Warning in betareg.fit(X, Y, Z, weights, offset, link, link.phi, type, control, #> : no valid starting value for precision parameter found, using 1 instead #> Warning in betareg.fit(X, Y, Z, weights, offset, link, link.phi, type, control, #> : no valid starting value for precision parameter found, using 1 instead #> Warning in betareg.fit(X, Y, Z, weights, offset, link, link.phi, type, control, #> : no valid starting value for precision parameter found, using 1 instead #> Warning in betareg.fit(X, Y, Z, weights, offset, link, link.phi, type, control, #> : no valid starting value for precision parameter found, using 1 instead #> Warning in betareg.fit(X, Y, Z, weights, offset, link, link.phi, type, control, #> : no valid starting value for precision parameter found, using 1 instead head(freq) #>    selector variable freq #> x1      AIC       x1 1.00 #> x2      AIC       x2 1.00 #> x3      AIC       x3 1.00 #> x4      AIC       x4 0.20 #> x5      AIC       x5 0.20 #> x6      AIC       x6 0.35 compare_table(single$table, freq) #>    selector variable          coef selected freq #> 1       AIC       x1  1.059016e+00     TRUE 1.00 #> 2       AIC       x2 -8.855152e-01     TRUE 1.00 #> 3       AIC       x3  7.277844e-01     TRUE 1.00 #> 4       AIC       x4  0.000000e+00    FALSE 0.20 #> 5       AIC       x5  0.000000e+00    FALSE 0.20 #> 6       AIC       x6  0.000000e+00    FALSE 0.35 #> 7      AICc       x1  1.059016e+00     TRUE 1.00 #> 8      AICc       x2 -8.855152e-01     TRUE 1.00 #> 9      AICc       x3  7.277844e-01     TRUE 1.00 #> 10     AICc       x4  0.000000e+00    FALSE 0.40 #> 11     AICc       x5  0.000000e+00    FALSE 0.10 #> 12     AICc       x6  0.000000e+00    FALSE 0.25 #> 13      BIC       x1  1.059016e+00     TRUE 1.00 #> 14      BIC       x2 -8.855152e-01     TRUE 1.00 #> 15      BIC       x3  7.277844e-01     TRUE 1.00 #> 16      BIC       x4  0.000000e+00    FALSE 0.05 #> 17      BIC       x5  0.000000e+00    FALSE 0.05 #> 18      BIC       x6  0.000000e+00    FALSE 0.10 #> 19   GLMNET       x1  9.901824e-01     TRUE 1.00 #> 20   GLMNET       x2 -8.043564e-01     TRUE 1.00 #> 21   GLMNET       x3  6.703246e-01     TRUE 1.00 #> 22   GLMNET       x4  0.000000e+00    FALSE 0.30 #> 23   GLMNET       x5  0.000000e+00    FALSE 0.30 #> 24   GLMNET       x6  0.000000e+00    FALSE 0.55 #> 25    LASSO       x1  1.088734e+00     TRUE 1.00 #> 26    LASSO       x2 -8.211508e-01     TRUE 1.00 #> 27    LASSO       x3  7.489369e-01     TRUE 1.00 #> 28    LASSO       x4  5.275007e-11     TRUE 1.00 #> 29    LASSO       x5 -1.981396e-05     TRUE 1.00 #> 30    LASSO       x6  4.151315e-02     TRUE 1.00"},{"path":"https://fbertran.github.io/SelectBoost.beta/articles/selectboost-cran.html","id":"interval-responses","dir":"Articles","previous_headings":"","what":"Interval responses","title":"Getting started with SelectBoost.beta","text":"outcome interval-censored, run sb_beta_interval() convenience wrapper. enables interval sampling logic inside sb_beta() keeping output format attributes. resulting stability matrix can summarised visualised exactly like point-response output shown earlier. ```","code":"y_low <- pmax(sim$Y - 0.05, 0) y_high <- pmin(sim$Y + 0.05, 1) interval_fit <- sb_beta_interval(sim$X, y_low, y_high, B = 30,   sample = \"uniform\", seed = 321) attr(interval_fit, \"interval\") #> [1] \"uniform\""},{"path":"https://fbertran.github.io/SelectBoost.beta/articles/simulate-interval-beta.html","id":"overview","dir":"Articles","previous_headings":"","what":"Overview","title":"Simulating interval Beta data","text":"simulation_DATA.beta() helper produces beta-regression design matrices paired either fully observed responses interval-censored outcomes. vignette illustrates typical workflow drawing single data set structured correlation custom missingness behaviour mimics practical survey settings. simulate 300 observations 10 candidate predictors. Four predictors truly associated response coefficients specified beta_size. Correlation among predictors follows AR(1) structure governed rho, conveniently induces near-multicollinearity remaining positive-definite.","code":"sim <- simulation_DATA.beta(   n = 300, p = 10, s = 4, beta_size = c(1.0, -0.8, 0.6, -0.5),   corr = \"ar1\", rho = 0.25,   mechanism = \"mixed\", mix_prob = 0.5,   delta = function(mu, X) 0.03 + 0.02 * abs(mu - 0.5),   alpha = function(mu, X) 0.1 + 0.05 * (mu < 0.3),   na_rate = 0.1, na_side = \"random\" )"},{"path":"https://fbertran.github.io/SelectBoost.beta/articles/simulate-interval-beta.html","id":"interval-generation-parameters","dir":"Articles","previous_headings":"Overview","what":"Interval-generation parameters","title":"Simulating interval Beta data","text":"delta alpha callbacks control often simulated outcome converted interval wide interval : delta(mu, X) encodes expected half-width interval around latent mean response mu. allow wider intervals mean far 0.5, highlighting heteroskedastic behaviour. alpha(mu, X) represents observation-specific inflation probability. latent mean 0.3, function returns larger values, creating lower-bound censoring small mu. mechanism = \"mixed\" mix_prob = 0.5, half affected observations receive two-sided intervals, whereas remainder experience one-sided censoring driven na_side = \"random\".","code":""},{"path":"https://fbertran.github.io/SelectBoost.beta/articles/simulate-interval-beta.html","id":"inspecting-the-simulated-outcomes","dir":"Articles","previous_headings":"Overview","what":"Inspecting the simulated outcomes","title":"Simulating interval Beta data","text":"output contains design matrix X, fully observed latent response Y, interval bounds Y_low/Y_high. following summaries check distribution latent response frequency interval-censoring. better understand resulting intervals can look small excerpt censored rows. Observations NA one side correspond one-sided censoring events.","code":"summary(sim$Y) #>      Min.   1st Qu.    Median      Mean   3rd Qu.      Max.  #> 0.0000517 0.2753408 0.5128178 0.4911643 0.6876537 0.9995677 mean(is.na(sim$Y_low) | is.na(sim$Y_high)) #> [1] 0.1 head(sim$Y_low, 10) #>  [1] 0.55301097 0.50072064 0.01690175 0.60189344 0.57207920 0.65266844 #>  [7]         NA 0.49181880 0.65886834 0.61582960 head(sim$Y_high, 10) #>  [1] 0.6134735 0.5639810 0.1837695 0.6631390 0.8845549 0.7249995 0.6155794 #>  [8] 0.8290800 0.7290462 0.9109949"},{"path":"https://fbertran.github.io/SelectBoost.beta/articles/simulate-interval-beta.html","id":"visualising-interval-widths","dir":"Articles","previous_headings":"Overview","what":"Visualising interval widths","title":"Simulating interval Beta data","text":"difference Y_high Y_low conveys much uncertainty interval carries. observation fully observed bounds coincide Y, leading zero width. histogram demonstrates , even modest base width 0.03, adaptive component delta() creates long right tail mean moves away centre unit interval.  simulated objects can passed directly modelling routines SelectBoost.beta. following sections outline turn generated intervals pseudo-observations classical selectors, obtain stable frequencies interval-aware fastboost routine, visualise results side side.","code":"interval_width <- sim$Y_high - sim$Y_low hist(interval_width, breaks = 30, col = \"#0A6AA6\", border = \"white\",      main = \"Distribution of simulated interval widths\",      xlab = \"Y_high - Y_low\")"},{"path":"https://fbertran.github.io/SelectBoost.beta/articles/simulate-interval-beta.html","id":"point-response-selectors-on-pseudo-observations","dir":"Articles","previous_headings":"","what":"Point-response selectors on pseudo-observations","title":"Simulating interval Beta data","text":"interval bounds observed, quick way obtain point response impute either midpoint available bound case one-sided censoring. helper keeps midpoint bounds present falls back observed edge otherwise. pseudo-response hand, can deploy full suite selectors shipped package. compare_selectors_single() wrapper runs stepwise AIC/BIC/AICc procedures, GAMLSS-based LASSO IRLS/glmnet approach one call. Setting include_enet = FALSE ensures example remains lightweight even optional gamlss.lasso extension installed. helper returns list two elements. single$coefs stores one coefficient vector per selector (intercept followed original column names), single$table provides tidy summary selector, variable, coef, selected columns. Column names briefly shortened internally guarantee syntactic validity selectors, mapped back original labels returned objects. bootstrap helper compare_selectors_bootstrap() repeats exercise resampled datasets, providing empirical selection frequencies method. freq column reports share bootstrap replicates variable selected. Higher values indicate stronger evidence across resamples help prioritise predictors follow-modelling. Merging outputs compare_table() gives compact summary containing per-run coefficients associated bootstrap frequencies.","code":"pseudo_y <- ifelse(   is.na(sim$Y_low) | is.na(sim$Y_high),   ifelse(is.na(sim$Y_low), sim$Y_high, sim$Y_low),   0.5 * (sim$Y_low + sim$Y_high) ) single <- compare_selectors_single(sim$X, pseudo_y, include_enet = FALSE) head(single$table) #>    selector variable       coef selected #> x1      AIC       x1  0.9204344     TRUE #> x2      AIC       x2 -0.7552439     TRUE #> x3      AIC       x3  0.5566513     TRUE #> x4      AIC       x4 -0.4996924     TRUE #> x5      AIC       x5  0.0000000    FALSE #> x6      AIC       x6  0.0000000    FALSE freq <- compare_selectors_bootstrap(   sim$X, pseudo_y, B = 15, include_enet = FALSE, seed = 321 ) head(freq) #>    selector variable       freq #> x1      AIC       x1 1.00000000 #> x2      AIC       x2 1.00000000 #> x3      AIC       x3 1.00000000 #> x4      AIC       x4 1.00000000 #> x5      AIC       x5 0.26666667 #> x6      AIC       x6 0.06666667 summary_tab <- compare_table(single$table, freq) head(summary_tab) #>   selector variable       coef selected      freq #> 1      AIC       x1  0.9204344     TRUE 1.0000000 #> 2      AIC      x10  0.0000000    FALSE 0.2000000 #> 3      AIC       x2 -0.7552439     TRUE 1.0000000 #> 4      AIC       x3  0.5566513     TRUE 1.0000000 #> 5      AIC       x4 -0.4996924     TRUE 1.0000000 #> 6      AIC       x5  0.0000000    FALSE 0.2666667"},{"path":"https://fbertran.github.io/SelectBoost.beta/articles/simulate-interval-beta.html","id":"visual-comparisons","dir":"Articles","previous_headings":"","what":"Visual comparisons","title":"Simulating interval Beta data","text":"package offers quick visualisation helpers default base graphics automatically use ggplot2 available. coefficient heatmap highlights variables selected estimated effect sizes across selectors.  Selection frequencies bootstrap stage can plotted manner, providing stability-oriented counterpart coefficient map.  Combining outputs compare_table() retains bootstrap frequencies next single-run coefficients easy inspection.","code":"plot_compare_coeff(single$table) plot_compare_freq(freq)"},{"path":"https://fbertran.github.io/SelectBoost.beta/articles/simulate-interval-beta.html","id":"interval-stability-selection-with-fastboost_interval","dir":"Articles","previous_headings":"","what":"Interval stability selection with fastboost_interval","title":"Simulating interval Beta data","text":"Instead reducing intervals single values, fastboost_interval() routine repeatedly samples pseudo-responses inside interval running chosen selector. resulting selection frequencies account uncertainty carried censored observations. additions demonstrate simulation engine, collection selectors, fast interval booster interact cohesive workflow interval-valued beta regression problems.","code":"fb <- fastboost_interval(   sim$X, sim$Y_low, sim$Y_high,   func = function(X, y) betareg_glmnet(X, y, choose = \"bic\", prestandardize = TRUE),   B = 30, seed = 99 ) sort(fb$freq, decreasing = TRUE)[1:5] #>        x1        x2        x3        x4        x8  #> 1.0000000 1.0000000 1.0000000 1.0000000 0.7333333"},{"path":"https://fbertran.github.io/SelectBoost.beta/articles/simulate-interval-beta.html","id":"interval-selectboost-with-sb_beta_interval","dir":"Articles","previous_headings":"","what":"Interval SelectBoost with sb_beta_interval","title":"Simulating interval Beta data","text":"want run full SelectBoost workflow interval data, sb_beta_interval() wrapper calls sb_beta() appropriate interval sampling mode hood. keeps output structure sb_beta() runs, including stability matrix diagnostic attributes. Pair output plotting methods (autoplot.sb_beta(), summary()) inspect stability matrix produced interval resampling.","code":"comp_id <- complete.cases(sim$Y_low) & complete.cases(sim$Y_high)  sb_interval <- sb_beta_interval(   sim$X[comp_id, ],   Y_low = sim$Y_low[comp_id],   Y_high = sim$Y_high[comp_id],   B = 30,   step.num = 0.4,   sample = \"uniform\" ) attr(sb_interval, \"interval\") #> [1] \"uniform\" head(sb_interval) #>                    x1        x2         x3         x4        x5        x6 #> c0 = 1.000 1.00000000 1.0000000 1.00000000 1.00000000 0.1666667 0.1000000 #> c0 = 0.138 0.23333333 0.1666667 0.20000000 0.06666667 0.2000000 0.2666667 #> c0 = 0.055 0.06666667 0.1333333 0.06666667 0.20000000 0.1333333 0.2333333 #> c0 = 0.000 0.06666667 0.2666667 0.13333333 0.13333333 0.1333333 0.2666667 #>                    x7        x8         x9        x10 phi|(Intercept) #> c0 = 1.000 0.60000000 0.3666667 0.06666667 0.20000000               1 #> c0 = 0.138 0.06666667 0.1000000 0.10000000 0.16666667               1 #> c0 = 0.055 0.16666667 0.1000000 0.06666667 0.06666667               1 #> c0 = 0.000 0.23333333 0.1666667 0.10000000 0.23333333               1 summary(sb_interval) #> SelectBoost beta summary #> Selector: selector #> Resamples per threshold: 30 #> Interval mode: uniform #> c0 grid: 1.000, 0.138, 0.055, 0.000 #> Inner thresholds: 0.138, 0.055 #> Top rows: #>    c0 variable frequency #> 1   1       x1    1.0000 #> 2   1       x2    0.2333 #> 3   1       x3    0.0667 #> 4   1       x4    0.0667 #> 5   1       x5    1.0000 #> 6   1       x6    0.1667 #> 7   1       x7    0.1333 #> 8   1       x8    0.2667 #> 9   1       x9    1.0000 #> 10  1      x10    0.2000 autoplot.sb_beta(sb_interval)"},{"path":"https://fbertran.github.io/SelectBoost.beta/authors.html","id":null,"dir":"","previous_headings":"","what":"Authors","title":"Authors and Citation","text":"Frederic Bertrand. Maintainer, author.","code":""},{"path":"https://fbertran.github.io/SelectBoost.beta/authors.html","id":"citation","dir":"","previous_headings":"","what":"Citation","title":"Authors and Citation","text":"Frédéric Bertrand (2025). Stability-Selection via Correlated Resampling Beta-Regression Models, R package version 0.4.5. Frédéric Bertrand Myriam Maumy (2023). Improving variable selection Beta regression models using correlated resampling. Joint Statistical Meetings 2023, Toronto, Canada. Frédéric Bertrand Myriam Maumy (2023). SelectBoost4Beta: Improving variable selection Beta regression models. BioC2023, Boston, MA, USA.","code":"@Manual{,   title = {Stability-Selection via Correlated Resampling for Beta-Regression Models},   author = {Frederic Bertrand},   year = {2025},   note = {R package version 0.4.5}, } @InProceedings{,   title = {Improving variable selection in Beta regression models using correlated resampling},   author = {Frédéric Bertrand and Myriam Maumy},   year = {2023},   booktitle = {Joint Statistical Meetings 2023},   address = {Toronto, Canada},   keywords = {generalized linear models linear models resampling simulation variable selection}, } @InProceedings{,   title = {SelectBoost4Beta: Improving variable selection in Beta regression models},   author = {Frédéric Bertrand and Myriam Maumy},   year = {2023},   booktitle = {BioC2023},   address = {Boston, MA, USA}, }"},{"path":"https://fbertran.github.io/SelectBoost.beta/index.html","id":"selectboostbeta-","dir":"","previous_headings":"","what":"Stability-Selection via Correlated Resampling for Beta-Regression Models","title":"Stability-Selection via Correlated Resampling for Beta-Regression Models","text":"growth big data, variable selection become one major challenges statistics. Although many methods proposed literature performance terms recall precision limited context number variables far exceeds number observations high correlated setting. Results: SelectBoost.beta brings correlation-aware resampling strategy original SelectBoost package beta regression implementing extension SelectBoost algorithm, F. Bertrand, . Aouadi, N. Jung, R. Carapito, L. Vallat, S. Bahram, M. Maumy-Bertrand (2015) https://doi.org/10.1093/bioinformatics/btaa855 https://doi.org/10.32614/CRAN.package.SelectBoost. ships : wrappers betareg_step_aic() betareg_glmnet() act base selectors beta-distributed outcomes, now including optional precision (phi) submodel search observation weights; helper functions (sb_normalize(), sb_group_variables(), sb_resample_groups(), …) mirroring core stages SelectBoost; high-level sb_beta() driver orchestrates normalisation, correlation analysis, grouped resampling stability tallying single call.","code":""},{"path":"https://fbertran.github.io/SelectBoost.beta/index.html","id":"choosing-a-selector","dir":"","previous_headings":"","what":"Choosing a selector","title":"Stability-Selection via Correlated Resampling for Beta-Regression Models","text":"SelectBoost.beta ships multiple selector families. Use table starting point deciding helper best matches workflow: selectors expect complete cases supplied design matrix act mean submodel. Offsets observation-level weights beyond exposed helper currently unsupported. resampling call returns per-group diagnostics (cached draws, observed correlation summaries) sb_beta() threads correlated surrogates across thresholds cross-level comparisons remain aligned. Interval responses supported interval argument, reuses fastboost_interval() logic directly inside sb_beta(). package designed stage workflow remains reusable . Users can plug custom grouping strategies selectors still benefiting correlated resampling.","code":""},{"path":"https://fbertran.github.io/SelectBoost.beta/index.html","id":"conference-presentations","dir":"","previous_headings":"","what":"Conference presentations","title":"Stability-Selection via Correlated Resampling for Beta-Regression Models","text":"SelectBoost4Beta approach presented Frédéric Bertrand Myriam Maumy Joint Statistical Meetings 2023 Toronto (“Improving variable selection Beta regression models using correlated resampling”) BioC2023 Boston (“SelectBoost4Beta: Improving variable selection Beta regression models”). communications highlighted correlated resampling boosts variable selection Beta regression high-dimensional, strongly correlated settings.","code":""},{"path":"https://fbertran.github.io/SelectBoost.beta/index.html","id":"installation","dir":"","previous_headings":"","what":"Installation","title":"Stability-Selection via Correlated Resampling for Beta-Regression Models","text":"SelectBoost.beta preparing first CRAN submission. becomes available , install development version GitHub: package lands CRAN, usual install.packages(\"SelectBoost.beta\") command work expected. selectors rely betareg, glmnet, gamlss ecosystems. packages pulled automatically installing source.","code":"devtools::install_github(\"fbertran/SelectBoost.beta\")"},{"path":"https://fbertran.github.io/SelectBoost.beta/index.html","id":"quick-start","dir":"","previous_headings":"","what":"Quick start","title":"Stability-Selection via Correlated Resampling for Beta-Regression Models","text":"Simulate correlated design, run manual SelectBoost steps betareg_step_aic(), compute selection frequencies: sb_beta() wrapper performs entire loop internally returns matrix indexed correlation thresholds used resampling: result stores selector used, number resamples, correlation thresholds attributes. Dedicated methods make easier inspect programmatically: plot chunk unnamed-chunk-33","code":"library(SelectBoost.beta) set.seed(42)  sim <- simulation_DATA.beta(n = 150, p = 6, s = 3, beta_size = c(1, -0.8, 0.6)) X_norm <- sb_normalize(sim$X) corr_mat <- sb_compute_corr(X_norm) groups <- sb_group_variables(corr_mat, c0 = 0.6) resamples <- sb_resample_groups(X_norm, groups, B = 50) coef_path <- sb_apply_selector_manual(X_norm, resamples, sim$Y, betareg_step_aic) sel_freq <- sb_selection_frequency(coef_path, version = \"glmnet\") sel_freq #>              x1              x2              x3              x4              x5              x6  #>               1               1               1               0               0               0  #> phi|(Intercept)  #>               1  attr(resamples, \"diagnostics\") #>   group size regenerated cached mean_abs_corr_orig mean_abs_corr_surrogate mean_abs_corr_cross #> 1    x1    1           0  FALSE                 NA                      NA                  NA #> 2    x2    1           0  FALSE                 NA                      NA                  NA #> 3    x3    1           0  FALSE                 NA                      NA                  NA #> 4    x4    1           0  FALSE                 NA                      NA                  NA #> 5    x5    1           0  FALSE                 NA                      NA                  NA #> 6    x6    1           0  FALSE                 NA                      NA                  NA sb <- sb_beta(sim$X, sim$Y, B = 50, step.num = 0.25,use.parallel = FALSE) print(sb) #> SelectBoost beta selection frequencies #> Selector: betareg_step_aic #> Resamples per threshold: 50 #> Interval mode: none #> c0 grid: 1.000, 0.089, 0.059, 0.030, 0.000 #> Inner thresholds: 0.089, 0.059, 0.030 #>              x1   x2   x3   x4   x5   x6 phi|(Intercept) #> c0 = 1.000 1.00 1.00 1.00 0.00 0.00 0.00               1 #> c0 = 0.089 0.24 0.14 0.14 0.18 0.14 0.18               1 #> c0 = 0.059 0.16 0.14 0.26 0.10 0.12 0.16               1 #> c0 = 0.030 0.20 0.14 0.14 0.12 0.18 0.20               1 #> c0 = 0.000 0.16 0.12 0.12 0.14 0.18 0.14               1 #> attr(,\"c0.seq\") #> [1] 1.00000000 0.08894615 0.05949716 0.03010630 0.00000000 #> attr(,\"steps.seq\") #> [1] 0.08894615 0.05949716 0.03010630 #> attr(,\"B\") #> [1] 50 #> attr(,\"selector\") #> [1] \"betareg_step_aic\" #> attr(,\"resample_diagnostics\") #> attr(,\"resample_diagnostics\")$`c0 = 1.000` #> [1] group                   size                    regenerated             #> [4] cached                  mean_abs_corr_orig      mean_abs_corr_surrogate #> [7] mean_abs_corr_cross     #> <0 rows> (or 0-length row.names) #>  #> attr(,\"resample_diagnostics\")$`c0 = 0.089` #>      group size regenerated cached mean_abs_corr_orig mean_abs_corr_surrogate #> 1    x1,x4    2          50  FALSE         0.08894615              0.10146558 #> 2 x2,x3,x6    3          50  FALSE         0.07694401              0.09829963 #> 3 x2,x3,x5    3          50  FALSE         0.08217406              0.09634851 #> 4    x3,x5    2          50  FALSE         0.09286939              0.09536360 #> 5    x2,x6    2          50  FALSE         0.10556609              0.11060608 #>   mean_abs_corr_cross #> 1          0.07089570 #> 2          0.06673431 #> 3          0.06390166 #> 4          0.05329723 #> 5          0.07179976 #>  #> attr(,\"resample_diagnostics\")$`c0 = 0.059` #>            group size regenerated cached mean_abs_corr_orig mean_abs_corr_surrogate #> 1    x1,x2,x3,x4    4          50  FALSE         0.06136428              0.08621443 #> 2 x1,x2,x3,x5,x6    5          50  FALSE         0.06152013              0.08582089 #> 3    x1,x2,x3,x5    4          50  FALSE         0.07198271              0.08974742 #> 4       x1,x4,x5    3          50  FALSE         0.06290784              0.07535777 #> 5    x2,x3,x4,x5    4          50  FALSE         0.05766823              0.08028623 #> 6          x2,x6    2           0   TRUE         0.10556609              0.11060608 #>   mean_abs_corr_cross #> 1          0.06598362 #> 2          0.06337853 #> 3          0.06489135 #> 4          0.06047434 #> 5          0.06062214 #> 6          0.07179976 #>  #> attr(,\"resample_diagnostics\")$`c0 = 0.030` #>               group size regenerated cached mean_abs_corr_orig mean_abs_corr_surrogate #> 1    x1,x2,x3,x4,x5    5          50  FALSE         0.06203296              0.08360476 #> 2    x1,x2,x3,x5,x6    5           0   TRUE         0.06152013              0.08582089 #> 3       x1,x4,x5,x6    4          50  FALSE         0.04694388              0.07252823 #> 4 x1,x2,x3,x4,x5,x6    6          50  FALSE         0.05666305              0.08518211 #> 5    x2,x3,x4,x5,x6    5          50  FALSE         0.05591031              0.08187888 #>   mean_abs_corr_cross #> 1          0.06487303 #> 2          0.06337853 #> 3          0.06954473 #> 4          0.06383341 #> 5          0.06182501 #>  #> attr(,\"resample_diagnostics\")$`c0 = 0.000` #>               group size regenerated cached mean_abs_corr_orig mean_abs_corr_surrogate #> 1 x1,x2,x3,x4,x5,x6    6           0   TRUE         0.05666305              0.08518211 #>   mean_abs_corr_cross #> 1          0.06383341 #>  #> attr(,\"interval\") #> [1] \"none\" summary(sb) #> SelectBoost beta summary #> Selector: betareg_step_aic #> Resamples per threshold: 50 #> Interval mode: none #> c0 grid: 1.000, 0.089, 0.059, 0.030, 0.000 #> Inner thresholds: 0.089, 0.059, 0.030 #> Top rows: #>        c0        variable frequency #> 1  1.0000              x1      1.00 #> 2  1.0000              x2      0.24 #> 3  1.0000              x3      0.16 #> 4  1.0000              x4      0.20 #> 5  1.0000              x5      0.16 #> 6  1.0000              x6      1.00 #> 7  1.0000 phi|(Intercept)      0.14 #> 8  0.0889              x1      0.14 #> 9  0.0889              x2      0.14 #> 10 0.0889              x3      0.12 if (requireNamespace(\"ggplot2\", quietly = TRUE)) {   autoplot.sb_beta(sb) } attr(sb, \"selector\") #> [1] \"betareg_step_aic\" attr(sb, \"c0.seq\") #> [1] 1.00000000 0.08894615 0.05949716 0.03010630 0.00000000 attr(sb, \"resample_diagnostics\")[[1]] #> [1] group                   size                    regenerated             #> [4] cached                  mean_abs_corr_orig      mean_abs_corr_surrogate #> [7] mean_abs_corr_cross     #> <0 rows> (or 0-length row.names)"},{"path":"https://fbertran.github.io/SelectBoost.beta/index.html","id":"understanding-the-sb_beta-output","dir":"","previous_headings":"Quick start","what":"Understanding the sb_beta() output","title":"Stability-Selection via Correlated Resampling for Beta-Regression Models","text":"matrix returned sb_beta() carries number attributes downstream code can recover stability frequencies produced: attr(sb, \"c0.seq\") lists absolute-correlation thresholds explored. attr(sb, \"steps.seq\") reports raw sequence used build grid step.num provided. attr(sb, \"B\") records number correlated resamples per threshold. attr(sb, \"selector\") stores selector name expression. attr(sb, \"interval\") highlights whether interval resampling used. attr(sb, \"resample_diagnostics\") holds per-threshold summaries cached surrogate draws. attributes mirror original SelectBoost design documented ?sb_beta ease CRAN review. compare_selectors_single() temporarily shortens column names selectors receive syntactically valid identifiers; returned list remaps coefficients long table back original labels. freq column reports often variable selected across bootstrap replicates. Values close 1 indicate highly stable discoveries, whereas small values suggest weak noisy support. Increase B need finer resolution; dozen resamples suffice quick checks, several hundred deliver smoother estimates. plot chunk unnamed-chunk-37 plot chunk unnamed-chunk-38","code":"single <- compare_selectors_single(sim$X, sim$Y, include_enet = TRUE) freq <- suppressWarnings(compare_selectors_bootstrap(   sim$X, sim$Y, B = 100, include_enet = TRUE, seed = 321 )) head(freq) #>    selector variable freq #> x1      AIC       x1 1.00 #> x2      AIC       x2 1.00 #> x3      AIC       x3 1.00 #> x4      AIC       x4 0.27 #> x5      AIC       x5 0.14 #> x6      AIC       x6 0.19 plot_compare_coeff(single$table) plot_compare_freq(freq)"},{"path":"https://fbertran.github.io/SelectBoost.beta/index.html","id":"interval-outcomes","dir":"","previous_headings":"Quick start","what":"Interval outcomes","title":"Stability-Selection via Correlated Resampling for Beta-Regression Models","text":"sb_beta() can draw pseudo-responses observed intervals supplying Y_low, Y_high, interval mode: shortcut always uses interval resampling, call sb_beta_interval(sim$X, Y_low, Y_high, sample = \"uniform\"). lower-level fastboost_interval() helper remains available want pair interval resampling logic custom selector outside sb_beta().","code":"interval_fit <- sb_beta(   sim$X,   Y_low = pmax(sim$Y - 0.05, 0),   Y_high = pmin(sim$Y + 0.05, 1),   interval = \"uniform\",   B = 30,   step.num = 0.5 ) attr(interval_fit, \"interval\") #> [1] \"uniform\" attr(interval_fit, \"resample_diagnostics\") #> $`c0 = 1.000` #> [1] group                   size                    regenerated             #> [4] cached                  mean_abs_corr_orig      mean_abs_corr_surrogate #> [7] mean_abs_corr_cross     #> <0 rows> (or 0-length row.names) #>  #> $`c0 = 0.059` #>            group size regenerated cached mean_abs_corr_orig mean_abs_corr_surrogate #> 1    x1,x2,x3,x4    4          30  FALSE         0.06136428              0.08625551 #> 2 x1,x2,x3,x5,x6    5          30  FALSE         0.06152013              0.08351693 #> 3    x1,x2,x3,x5    4          30  FALSE         0.07198271              0.09395737 #> 4       x1,x4,x5    3          30  FALSE         0.06290784              0.08889440 #> 5    x2,x3,x4,x5    4          30  FALSE         0.05766823              0.08401650 #> 6          x2,x6    2          30  FALSE         0.10556609              0.08760037 #>   mean_abs_corr_cross #> 1          0.06004899 #> 2          0.07278975 #> 3          0.06294279 #> 4          0.07196982 #> 5          0.06221965 #> 6          0.06647446 #>  #> $`c0 = 0.000` #>               group size regenerated cached mean_abs_corr_orig mean_abs_corr_surrogate #> 1 x1,x2,x3,x4,x5,x6    6          30  FALSE         0.05666305              0.08808704 #>   mean_abs_corr_cross #> 1          0.05790142"},{"path":"https://fbertran.github.io/SelectBoost.beta/index.html","id":"response-handling-and-squeezing","dir":"","previous_headings":"Quick start","what":"Response handling and squeezing","title":"Stability-Selection via Correlated Resampling for Beta-Regression Models","text":"selectors operate responses (0, 1). default sb_beta() selector helpers squeeze data away boundaries using usual SelectBoost transformation. Set squeeze = FALSE already applied transformation; otherwise zero/one observations trigger error.","code":""},{"path":"https://fbertran.github.io/SelectBoost.beta/index.html","id":"parallel-resampling","dir":"","previous_headings":"Quick start","what":"Parallel resampling","title":"Stability-Selection via Correlated Resampling for Beta-Regression Models","text":"Setting use.parallel = TRUE instructs sb_beta() sb_resample_groups() dispatch resamples selector fits future.apply. Bring future::plan() select desired backend (e.g. multisession desktops): Refer vignettes detailed walk-workflow pseudo-code underpinning algorithms. new Getting started SelectBoost.beta vignette mirrors CRAN submission example set showing full run, interpreting stability matrix, comparing selectors side side.","code":"future::plan(future::multisession) sb_parallel <- sb_beta(sim$X, sim$Y, B = 50, step.num = 0.25, use.parallel = TRUE) future::plan(future::sequential)"},{"path":"https://fbertran.github.io/SelectBoost.beta/reference/SelectBoost.beta-package.html","id":null,"dir":"Reference","previous_headings":"","what":"SelectBoost.beta: Stability-Selection via Correlated Resampling for Beta-Regression Models — SelectBoost.beta-package","title":"SelectBoost.beta: Stability-Selection via Correlated Resampling for Beta-Regression Models — SelectBoost.beta-package","text":"Adds variable-selection functions Beta regression models (mean submodel) can used within 'SelectBoost' algorithm. Includes stepwise 'AIC'/'BIC'/'AICc' betareg() fits, 'GAMLSS'-based LASSO/Elastic-Net, pure 'glmnet' 'IRLS'-based selector optional standardization speedup, C++ helpers 'IRLS' working steps precision updates. Also provides fastboost_interval() variant interval responses, comparison helpers, flexible simulator simulation_DATA.beta() interval-valued data. 'SelectBoost4Beta' framework presented Bertrand 'Maumy' (2023) Joint Statistical Meetings 2023 (Toronto, Canada) 'BioC2023' (Boston, USA), highlighting correlated resampling Beta-regression variable selection.","code":""},{"path":"https://fbertran.github.io/SelectBoost.beta/reference/SelectBoost.beta-package.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"SelectBoost.beta: Stability-Selection via Correlated Resampling for Beta-Regression Models — SelectBoost.beta-package","text":"Bertrand, F. Maumy, M. (2023). Improving variable selection Beta regression models using correlated resampling. Presented Joint Statistical Meetings 2023, Toronto, Canada. Bertrand, F. Maumy, M. (2023). SelectBoost4Beta: Improving variable selection Beta regression models. Presented BioC2023, Boston, USA.","code":""},{"path":[]},{"path":"https://fbertran.github.io/SelectBoost.beta/reference/SelectBoost.beta-package.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"SelectBoost.beta: Stability-Selection via Correlated Resampling for Beta-Regression Models — SelectBoost.beta-package","text":"package written Frédéric Bertrand. Maintainer: Frédéric Bertrand frederic.bertrand@lecnam.net","code":""},{"path":"https://fbertran.github.io/SelectBoost.beta/reference/SelectBoost.beta-package.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"SelectBoost.beta: Stability-Selection via Correlated Resampling for Beta-Regression Models — SelectBoost.beta-package","text":"","code":"set.seed(1) n <- 150; p <- 6 X <- matrix(rnorm(n*p), n, p); colnames(X) <- paste0(\"x\",1:p) eta <- 0.4 + X[,1] - 0.7*X[,3] mu  <- plogis(eta) Y   <- rbeta(n, mu*25, (1-mu)*25)  betareg_step_aic(X, Y)    # should return (Intercept) + x1,x3 nonzero often #> (Intercept)          x1          x2          x3          x4          x5  #>   0.3840811   1.0104247   0.0000000  -0.6555926   0.0000000   0.0000000  #>          x6  #>   0.0000000  betareg_step_bic(X, Y) #> (Intercept)          x1          x2          x3          x4          x5  #>   0.3840811   1.0104247   0.0000000  -0.6555926   0.0000000   0.0000000  #>          x6  #>   0.0000000  betareg_step_aicc(X, Y) #> (Intercept)          x1          x2          x3          x4          x5  #>   0.3840811   1.0104247   0.0000000  -0.6555926   0.0000000   0.0000000  #>          x6  #>   0.0000000"},{"path":"https://fbertran.github.io/SelectBoost.beta/reference/betareg_enet_gamlss.html","id":null,"dir":"Reference","previous_headings":"","what":"Beta regression Elastic-Net via GAMLSS (gamlss.lasso) — betareg_enet_gamlss","title":"Beta regression Elastic-Net via GAMLSS (gamlss.lasso) — betareg_enet_gamlss","text":"Uses gamlss.lasso::gnet() fit ENet mean submodel gamlss(dist = ). routine assumes complete cases expose offsets precision-model terms.","code":""},{"path":"https://fbertran.github.io/SelectBoost.beta/reference/betareg_enet_gamlss.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Beta regression Elastic-Net via GAMLSS (gamlss.lasso) — betareg_enet_gamlss","text":"","code":"betareg_enet_gamlss(   X,   Y,   method = c(\"IC\", \"CV\"),   ICpen = c(\"BIC\", \"AIC\", \"HQC\"),   alpha = 1,   trace = FALSE )"},{"path":"https://fbertran.github.io/SelectBoost.beta/reference/betareg_enet_gamlss.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Beta regression Elastic-Net via GAMLSS (gamlss.lasso) — betareg_enet_gamlss","text":"X Numeric matrix (n × p) mean-submodel predictors. Y Numeric response (0,1). Values squeezed (0,1) internally. method \"IC\" (information criterion) \"CV\". ICpen Penalty \"IC\" selection: \"BIC\", \"AIC\", \"HQC\". alpha Elastic-net mixing (1 = LASSO, 0 = ridge). trace Logical; print stepwise trace.","code":""},{"path":"https://fbertran.github.io/SelectBoost.beta/reference/betareg_enet_gamlss.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Beta regression Elastic-Net via GAMLSS (gamlss.lasso) — betareg_enet_gamlss","text":"Named numeric vector coefficients betareg_lasso_gamlss().","code":""},{"path":[]},{"path":"https://fbertran.github.io/SelectBoost.beta/reference/betareg_glmnet.html","id":null,"dir":"Reference","previous_headings":"","what":"Pure glmnet IRLS selector for Beta regression — betareg_glmnet","title":"Pure glmnet IRLS selector for Beta regression — betareg_glmnet","text":"Runs IRLS loop Beta working responses/weights calls glmnet weighted least-squares surrogate. Supports BIC/AIC/CV model choice optional prestandardize speedup. helper uses mean submodel, requires complete cases, expose offset terms.","code":""},{"path":"https://fbertran.github.io/SelectBoost.beta/reference/betareg_glmnet.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Pure glmnet IRLS selector for Beta regression — betareg_glmnet","text":"","code":"betareg_glmnet(   X,   Y,   alpha = 1,   choose = c(\"bic\", \"aic\", \"cv\"),   nfolds = 5,   n_iter = 6,   tol = 1e-05,   standardize = TRUE,   lambda = NULL,   phi_init = 20,   update_phi = TRUE,   phi_maxit = 5,   prestandardize = FALSE,   trace = FALSE )"},{"path":"https://fbertran.github.io/SelectBoost.beta/reference/betareg_glmnet.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Pure glmnet IRLS selector for Beta regression — betareg_glmnet","text":"X Numeric matrix (n × p) mean-submodel predictors. Y Numeric response (0,1). Values squeezed (0,1) internally. alpha Elastic-net mixing parameter. choose One \"bic\", \"aic\", \"cv\" pick lambda. nfolds Folds CV choose = \"cv\". n_iter Max IRLS iterations; tol Convergence tolerance IRLS parameter change (Euclidean norm difference [a0, beta]), default 1e-5. standardize Forwarded glmnet (ignored prestandardize = TRUE). lambda Optional fixed lambda; NULL, chosen choose. phi_init Initial precision (phi). update_phi Logical; update phi inside IRLS loop. phi_maxit Newton steps phi update. prestandardize TRUE, manually center/scale X disable glmnet's internal standardization (speed trick). trace Logical; print IRLS progress.","code":""},{"path":"https://fbertran.github.io/SelectBoost.beta/reference/betareg_glmnet.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Pure glmnet IRLS selector for Beta regression — betareg_glmnet","text":"Named numeric vector (Intercept) + colnames(X) zeros unselected variables.","code":""},{"path":[]},{"path":"https://fbertran.github.io/SelectBoost.beta/reference/betareg_glmnet.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Pure glmnet IRLS selector for Beta regression — betareg_glmnet","text":"","code":"set.seed(1); X <- matrix(rnorm(500), 100, 5); Y <- plogis(X[,1]-0.5*X[,3]) Y <- rbeta(100, Y*40, (1-Y)*40) betareg_glmnet(X, Y, alpha = 1, choose = \"bic\", prestandardize = TRUE) #> (Intercept)          X1          X2          X3          X4          X5  #>  0.02373154  0.90342704  0.00000000 -0.44090079  0.00000000  0.00000000"},{"path":"https://fbertran.github.io/SelectBoost.beta/reference/betareg_lasso_gamlss.html","id":null,"dir":"Reference","previous_headings":"","what":"Beta regression LASSO via GAMLSS — betareg_lasso_gamlss","title":"Beta regression LASSO via GAMLSS — betareg_lasso_gamlss","text":"Uses gamlss::ri() (L1 penalty) gamlss(dist = ) mean submodel select variables. helper works complete cases X/Y, targets mean component, yet expose offset handling.","code":""},{"path":"https://fbertran.github.io/SelectBoost.beta/reference/betareg_lasso_gamlss.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Beta regression LASSO via GAMLSS — betareg_lasso_gamlss","text":"","code":"betareg_lasso_gamlss(   X,   Y,   method = c(\"ML\", \"GAIC\"),   k = 2,   degf = NULL,   lambda = NULL,   trace = FALSE )"},{"path":"https://fbertran.github.io/SelectBoost.beta/reference/betareg_lasso_gamlss.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Beta regression LASSO via GAMLSS — betareg_lasso_gamlss","text":"X Numeric matrix (n × p) mean-submodel predictors. Y Numeric response (0,1). Values squeezed (0,1) internally. method \"ML\" \"GAIC\" (see gamlss::ri). k Penalty multiplier GAIC method = \"GAIC\". degf Optional degrees freedom L1 term. lambda Optional penalty strength. trace Logical; print stepwise trace.","code":""},{"path":"https://fbertran.github.io/SelectBoost.beta/reference/betareg_lasso_gamlss.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Beta regression LASSO via GAMLSS — betareg_lasso_gamlss","text":"Named numeric vector coefficients (Intercept) + colnames(X), 0 unselected variables.","code":""},{"path":[]},{"path":"https://fbertran.github.io/SelectBoost.beta/reference/betareg_lasso_gamlss.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Beta regression LASSO via GAMLSS — betareg_lasso_gamlss","text":"","code":"set.seed(1); X <- matrix(rnorm(300), 100, 3); Y <- plogis(X[,1]); Y <- rbeta(100, Y*30, (1-Y)*30) betareg_lasso_gamlss(X, Y, method = \"GAIC\", k = 2) #>   (Intercept)            X1            X2            X3  #>  9.964032e-02  8.139031e-01 -1.277365e-04  2.804953e-06"},{"path":"https://fbertran.github.io/SelectBoost.beta/reference/betareg_step_aic.html","id":null,"dir":"Reference","previous_headings":"","what":"Stepwise Beta regression by AIC — betareg_step_aic","title":"Stepwise Beta regression by AIC — betareg_step_aic","text":"Fits Beta regression optional joint selection mean precision (phi) submodels using betareg::betareg(). routine performs greedy forward/backward search using requested information criterion returns coefficients aligned supplied design matrix. selectors currently target mean submodel , require complete cases, expose offsets. Observation weights passed betareg() provided.","code":""},{"path":"https://fbertran.github.io/SelectBoost.beta/reference/betareg_step_aic.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Stepwise Beta regression by AIC — betareg_step_aic","text":"","code":"betareg_step_aic(   X,   Y,   direction = \"both\",   link = \"logit\",   link.phi = \"log\",   type = \"ML\",   trace = FALSE,   max_steps = NULL,   epsilon = 1e-08,   X_phi = NULL,   direction_phi = c(\"none\", \"both\", \"forward\", \"backward\"),   weights = NULL )"},{"path":"https://fbertran.github.io/SelectBoost.beta/reference/betareg_step_aic.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Stepwise Beta regression by AIC — betareg_step_aic","text":"X Numeric matrix (n × p) mean-submodel predictors. Y Numeric response (0,1). Values squeezed (0,1) internally. direction Stepwise direction mean submodel: \"\", \"forward\", \"backward\". link Link mean submodel (passed betareg). Default \"logit\". link.phi Link precision parameter. Default \"log\". type Likelihood type betareg, e.g. \"ML\". trace Logical; print stepwise trace. max_steps Integer; maximum number greedy steps (default p). epsilon Numeric; minimum improvement required accept move (default 1e-8). X_phi Optional matrix candidate predictors precision (phi) submodel. direction_phi enables precision updates X_phi NULL, function reuses X. direction_phi Stepwise direction precision submodel. Defaults \"none\" (phi selection). Supported values mirror direction. weights Optional non-negative observation weights passed betareg().","code":""},{"path":"https://fbertran.github.io/SelectBoost.beta/reference/betareg_step_aic.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Stepwise Beta regression by AIC — betareg_step_aic","text":"Named numeric vector length p_mean + p_phi + 1 containing intercept, mean coefficients, phi-intercept (prefixed \"phi|\"), phi coefficients (also prefixed \"phi|\"). Non-selected variables coefficient 0.","code":""},{"path":[]},{"path":"https://fbertran.github.io/SelectBoost.beta/reference/betareg_step_aic.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Stepwise Beta regression by AIC — betareg_step_aic","text":"","code":"set.seed(1) X <- matrix(rnorm(200), 100, 2); Y <- plogis(0.5 + X[,1]-X[,2]); betareg_step_aic(X, Y) #>     (Intercept)              X1              X2 phi|(Intercept)  #>       0.4913849       0.9816406      -0.9826776      11.1205505  Y <- rbeta(100, Y*20, (1-Y)*20) betareg_step_aic(X, Y) #>     (Intercept)              X1              X2 phi|(Intercept)  #>       0.3941879       0.9889555      -0.8456512       3.2232473"},{"path":"https://fbertran.github.io/SelectBoost.beta/reference/betareg_step_aicc.html","id":null,"dir":"Reference","previous_headings":"","what":"Stepwise Beta regression by AICc (finite-sample corrected AIC) — betareg_step_aicc","title":"Stepwise Beta regression by AICc (finite-sample corrected AIC) — betareg_step_aicc","text":"Greedy forward/backward search minimizing AICc computed betareg fits optional precision-submodel selection observation weights.","code":""},{"path":"https://fbertran.github.io/SelectBoost.beta/reference/betareg_step_aicc.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Stepwise Beta regression by AICc (finite-sample corrected AIC) — betareg_step_aicc","text":"","code":"betareg_step_aicc(   X,   Y,   direction = \"both\",   link = \"logit\",   link.phi = \"log\",   type = \"ML\",   trace = FALSE,   max_steps = NULL,   epsilon = 1e-08,   X_phi = NULL,   direction_phi = c(\"none\", \"both\", \"forward\", \"backward\"),   weights = NULL )"},{"path":"https://fbertran.github.io/SelectBoost.beta/reference/betareg_step_aicc.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Stepwise Beta regression by AICc (finite-sample corrected AIC) — betareg_step_aicc","text":"X Numeric matrix (n × p) mean-submodel predictors. Y Numeric response (0,1). Values squeezed (0,1) internally. direction Stepwise direction mean submodel: \"\", \"forward\", \"backward\". link Link mean submodel (passed betareg). Default \"logit\". link.phi Link precision parameter. Default \"log\". type Likelihood type betareg, e.g. \"ML\". trace Logical; print stepwise trace. max_steps Maximum number greedy steps (default p). epsilon Minimal AICc improvement accept move. X_phi Optional matrix candidate predictors precision (phi) submodel. direction_phi enables precision updates X_phi NULL, function reuses X. direction_phi Stepwise direction precision submodel. Defaults \"none\" (phi selection). Supported values mirror direction. weights Optional non-negative observation weights passed betareg().","code":""},{"path":"https://fbertran.github.io/SelectBoost.beta/reference/betareg_step_aicc.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Stepwise Beta regression by AICc (finite-sample corrected AIC) — betareg_step_aicc","text":"See betareg_step_aic().","code":""},{"path":"https://fbertran.github.io/SelectBoost.beta/reference/betareg_step_aicc.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Stepwise Beta regression by AICc (finite-sample corrected AIC) — betareg_step_aicc","text":"","code":"set.seed(1); X <- matrix(rnorm(400), 100, 4); Y <- plogis(X[,1]+0.5*X[,2]) betareg_step_aicc(X, Y) #>     (Intercept)              X1              X2              X3              X4  #>    3.248654e-04    9.858079e-01    4.932358e-01    0.000000e+00    0.000000e+00  #> phi|(Intercept)  #>    1.307252e+01  Y <- rbeta(100, Y*25, (1-Y)*25); betareg_step_aicc(X, Y) #>     (Intercept)              X1              X2              X3              X4  #>    -0.009987406     1.044515121     0.532545592     0.000000000     0.000000000  #> phi|(Intercept)  #>     3.135373326"},{"path":"https://fbertran.github.io/SelectBoost.beta/reference/betareg_step_bic.html","id":null,"dir":"Reference","previous_headings":"","what":"Stepwise Beta regression by BIC — betareg_step_bic","title":"Stepwise Beta regression by BIC — betareg_step_bic","text":"Stepwise Beta regression BIC","code":""},{"path":"https://fbertran.github.io/SelectBoost.beta/reference/betareg_step_bic.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Stepwise Beta regression by BIC — betareg_step_bic","text":"","code":"betareg_step_bic(   X,   Y,   direction = \"both\",   link = \"logit\",   link.phi = \"log\",   type = \"ML\",   trace = FALSE,   max_steps = NULL,   epsilon = 1e-08,   X_phi = NULL,   direction_phi = c(\"none\", \"both\", \"forward\", \"backward\"),   weights = NULL )"},{"path":"https://fbertran.github.io/SelectBoost.beta/reference/betareg_step_bic.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Stepwise Beta regression by BIC — betareg_step_bic","text":"X Numeric matrix (n × p) mean-submodel predictors. Y Numeric response (0,1). Values squeezed (0,1) internally. direction Stepwise direction mean submodel: \"\", \"forward\", \"backward\". link Link mean submodel (passed betareg). Default \"logit\". link.phi Link precision parameter. Default \"log\". type Likelihood type betareg, e.g. \"ML\". trace Logical; print stepwise trace. max_steps Integer; maximum number greedy steps (default p). epsilon Numeric; minimum improvement required accept move (default 1e-8). X_phi Optional matrix candidate predictors precision (phi) submodel. direction_phi enables precision updates X_phi NULL, function reuses X. direction_phi Stepwise direction precision submodel. Defaults \"none\" (phi selection). Supported values mirror direction. weights Optional non-negative observation weights passed betareg().","code":""},{"path":"https://fbertran.github.io/SelectBoost.beta/reference/betareg_step_bic.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Stepwise Beta regression by BIC — betareg_step_bic","text":"See betareg_step_aic().","code":""},{"path":"https://fbertran.github.io/SelectBoost.beta/reference/betareg_step_bic.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Stepwise Beta regression by BIC — betareg_step_bic","text":"","code":"set.seed(1); X <- matrix(rnorm(300), 100, 3); Y <- plogis(X[,1]); betareg_step_bic(X, Y) #>     (Intercept)              X1              X2              X3 phi|(Intercept)  #>    9.240039e-05    9.864092e-01    0.000000e+00    0.000000e+00    1.357490e+01  Y <- rbeta(100, Y*30, (1-Y)*30) betareg_step_bic(X, Y) #>     (Intercept)              X1              X2              X3 phi|(Intercept)  #>    -0.001531718     0.932506105     0.000000000     0.000000000     3.533825847"},{"path":"https://fbertran.github.io/SelectBoost.beta/reference/compare_selectors_bootstrap.html","id":null,"dir":"Reference","previous_headings":"","what":"Bootstrap selection frequencies across selectors — compare_selectors_bootstrap","title":"Bootstrap selection frequencies across selectors — compare_selectors_bootstrap","text":"Bootstraps dataset B times records often variable selected selector. Observations containing NA either X Y removed prior resampling. Column names abbreviated internally mapped back originals output just like compare_selectors_single().","code":""},{"path":"https://fbertran.github.io/SelectBoost.beta/reference/compare_selectors_bootstrap.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Bootstrap selection frequencies across selectors — compare_selectors_bootstrap","text":"","code":"compare_selectors_bootstrap(X, Y, B = 50, include_enet = TRUE, seed = NULL)"},{"path":"https://fbertran.github.io/SelectBoost.beta/reference/compare_selectors_bootstrap.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Bootstrap selection frequencies across selectors — compare_selectors_bootstrap","text":"X Numeric matrix (n × p) mean-submodel predictors. Y Numeric response (0,1). Values squeezed (0,1) internally. B Number bootstrap replications. include_enet Logical; include ENet gamlss.lasso installed. seed Optional RNG seed.","code":""},{"path":"https://fbertran.github.io/SelectBoost.beta/reference/compare_selectors_bootstrap.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Bootstrap selection frequencies across selectors — compare_selectors_bootstrap","text":"Long data frame columns selector, variable, freq [0,1]. freq column reports share bootstrap replicates variable selected corresponding selector; values near 1 signal high stability whereas small values indicate weak evidence.","code":""},{"path":"https://fbertran.github.io/SelectBoost.beta/reference/compare_selectors_bootstrap.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Bootstrap selection frequencies across selectors — compare_selectors_bootstrap","text":"","code":"set.seed(1) X <- matrix(rnorm(300), 100, 3); Y <- plogis(X[, 1]) Y <- rbeta(100, Y * 30, (1 - Y) * 30) freq <- compare_selectors_bootstrap(X, Y, B = 10, include_enet = FALSE) head(freq) #>     selector variable freq #> X1       AIC       X1  1.0 #> X2       AIC       X2  0.0 #> X3       AIC       X3  0.5 #> X11      BIC       X1  1.0 #> X21      BIC       X2  0.0 #> X31      BIC       X3  0.0"},{"path":"https://fbertran.github.io/SelectBoost.beta/reference/compare_selectors_single.html","id":null,"dir":"Reference","previous_headings":"","what":"Run all selectors once on a dataset — compare_selectors_single","title":"Run all selectors once on a dataset — compare_selectors_single","text":"Convenience wrapper runs AIC/BIC/AICc stepwise, GAMLSS LASSO (ENet available), pure glmnet IRLS selector, collates coefficients long table comparison. Observations containing NA either X Y removed prior fitting. Column names temporarily shortened satisfy selector requirements avoid clashes; outputs remap original labels returning.","code":""},{"path":"https://fbertran.github.io/SelectBoost.beta/reference/compare_selectors_single.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Run all selectors once on a dataset — compare_selectors_single","text":"","code":"compare_selectors_single(X, Y, include_enet = TRUE)"},{"path":"https://fbertran.github.io/SelectBoost.beta/reference/compare_selectors_single.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Run all selectors once on a dataset — compare_selectors_single","text":"X Numeric matrix (n × p) mean-submodel predictors. Y Numeric response (0,1). Values squeezed (0,1) internally. include_enet Logical; include ENet gamlss.lasso installed.","code":""},{"path":"https://fbertran.github.io/SelectBoost.beta/reference/compare_selectors_single.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Run all selectors once on a dataset — compare_selectors_single","text":"list : coefs Named coefficient vectors selector. table Long data frame columns selector, variable, coef, selected.","code":""},{"path":"https://fbertran.github.io/SelectBoost.beta/reference/compare_selectors_single.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Run all selectors once on a dataset — compare_selectors_single","text":"","code":"set.seed(1) X <- matrix(rnorm(300), 100, 3); Y <- plogis(X[, 1]) Y <- rbeta(100, Y * 30, (1 - Y) * 30) single <- compare_selectors_single(X, Y, include_enet = FALSE) head(single$table) #>     selector variable      coef selected #> X1       AIC       X1 0.9325061     TRUE #> X2       AIC       X2 0.0000000    FALSE #> X3       AIC       X3 0.0000000    FALSE #> X11      BIC       X1 0.9325061     TRUE #> X21      BIC       X2 0.0000000    FALSE #> X31      BIC       X3 0.0000000    FALSE"},{"path":"https://fbertran.github.io/SelectBoost.beta/reference/compare_table.html","id":null,"dir":"Reference","previous_headings":"","what":"Merge single-run results and bootstrap frequencies — compare_table","title":"Merge single-run results and bootstrap frequencies — compare_table","text":"Merge single-run results bootstrap frequencies","code":""},{"path":"https://fbertran.github.io/SelectBoost.beta/reference/compare_table.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Merge single-run results and bootstrap frequencies — compare_table","text":"","code":"compare_table(single_tab, freq_tab = NULL)"},{"path":"https://fbertran.github.io/SelectBoost.beta/reference/compare_table.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Merge single-run results and bootstrap frequencies — compare_table","text":"single_tab Data frame returned compare_selectors_single()[[\"table\"]]. freq_tab Optional frequency table compare_selectors_bootstrap().","code":""},{"path":"https://fbertran.github.io/SelectBoost.beta/reference/compare_table.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Merge single-run results and bootstrap frequencies — compare_table","text":"Merged data frame.","code":""},{"path":"https://fbertran.github.io/SelectBoost.beta/reference/compare_table.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Merge single-run results and bootstrap frequencies — compare_table","text":"","code":"single_tab <- data.frame(   selector = rep(c(\"AIC\", \"BIC\"), each = 3),   variable = rep(paste0(\"x\", 1:3), times = 2),   coef = c(0.5, 0, -0.2, 0.6, 0.1, -0.3) ) single_tab$selected <- single_tab$coef != 0 freq_tab <- data.frame(   selector = rep(c(\"AIC\", \"BIC\"), each = 3),   variable = rep(paste0(\"x\", 1:3), times = 2),   freq = c(0.9, 0.15, 0.4, 0.85, 0.3, 0.25) ) compare_table(single_tab, freq_tab) #>   selector variable coef selected freq #> 1      AIC       x1  0.5     TRUE 0.90 #> 2      AIC       x2  0.0    FALSE 0.15 #> 3      AIC       x3 -0.2     TRUE 0.40 #> 4      BIC       x1  0.6     TRUE 0.85 #> 5      BIC       x2  0.1     TRUE 0.30 #> 6      BIC       x3 -0.3     TRUE 0.25"},{"path":"https://fbertran.github.io/SelectBoost.beta/reference/fastboost_interval.html","id":null,"dir":"Reference","previous_headings":"","what":"Interval-response stability selection (fastboost variant) — fastboost_interval","title":"Interval-response stability selection (fastboost variant) — fastboost_interval","text":"Repeats selection interval-valued responses sampling pseudo-response interval (uniformly midpoint), tallying variable selection frequencies across B replicates.","code":""},{"path":"https://fbertran.github.io/SelectBoost.beta/reference/fastboost_interval.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Interval-response stability selection (fastboost variant) — fastboost_interval","text":"","code":"fastboost_interval(   X,   Y_low,   Y_high,   func,   B = 100,   sample = c(\"uniform\", \"midpoint\"),   version = \"glmnet\",   use.parallel = FALSE,   seed = NULL,   ... )"},{"path":"https://fbertran.github.io/SelectBoost.beta/reference/fastboost_interval.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Interval-response stability selection (fastboost variant) — fastboost_interval","text":"X Numeric matrix (n × p). Y_low, Y_high Interval bounds [0,1]. Rows missing bounds dropped. func Function function(X, y, ...) returning named coefficient vector selectors (nonselected = 0). B Number interval resamples. sample \"uniform\" (default) \"midpoint\" drawing pseudo-responses. version Ignored (reserved future). use.parallel Use parallel::mclapply available. seed Optional RNG seed. ... Extra args forwarded func.","code":""},{"path":"https://fbertran.github.io/SelectBoost.beta/reference/fastboost_interval.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Interval-response stability selection (fastboost variant) — fastboost_interval","text":"list : betas B × (p+1) matrix coefficients replicates. freq Named vector selection frequencies predictor.","code":""},{"path":"https://fbertran.github.io/SelectBoost.beta/reference/fastboost_interval.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Interval-response stability selection (fastboost variant) — fastboost_interval","text":"","code":"# suppose you have interval data (Y_low, Y_high) set.seed(1) n <- 120; p <- 6 X <- matrix(rnorm(n*p), n, p); colnames(X) <- paste0(\"x\",1:p) mu <- plogis(X[,1] - 0.5*X[,2]); Y <- rbeta(n, mu*25, (1-mu)*25) Y_low <- pmax(0, Y - 0.05); Y_high <- pmin(1, Y + 0.05) fb <- fastboost_interval(X, Y_low, Y_high,        func = function(X,y) betareg_glmnet(X,y, choose=\"bic\", prestandardize=TRUE),        B = 40) sort(fb$freq, decreasing = TRUE) #> x1 x2 x3 x4 x5 x6  #>  1  1  0  0  0  0"},{"path":"https://fbertran.github.io/SelectBoost.beta/reference/plot_compare_coeff.html","id":null,"dir":"Reference","previous_headings":"","what":"Side-by-side coefficient heatmap — plot_compare_coeff","title":"Side-by-side coefficient heatmap — plot_compare_coeff","text":"Visual comparison coefficients returned selector. Requires ggplot2.","code":""},{"path":"https://fbertran.github.io/SelectBoost.beta/reference/plot_compare_coeff.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Side-by-side coefficient heatmap — plot_compare_coeff","text":"","code":"plot_compare_coeff(single_tab)"},{"path":"https://fbertran.github.io/SelectBoost.beta/reference/plot_compare_coeff.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Side-by-side coefficient heatmap — plot_compare_coeff","text":"single_tab Data frame returned compare_selectors_single()[[\"table\"]].","code":""},{"path":"https://fbertran.github.io/SelectBoost.beta/reference/plot_compare_coeff.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Side-by-side coefficient heatmap — plot_compare_coeff","text":"ggplot object ggplot2 available; otherwise draws base R image.","code":""},{"path":"https://fbertran.github.io/SelectBoost.beta/reference/plot_compare_coeff.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Side-by-side coefficient heatmap — plot_compare_coeff","text":"","code":"demo_tab <- data.frame(   selector = rep(c(\"AIC\", \"BIC\"), each = 3),   variable = rep(paste0(\"x\", 1:3), times = 2),   coef = c(0.6, 0, -0.2, 0.55, 0.05, -0.3) ) demo_tab$selected <- demo_tab$coef != 0 plot_compare_coeff(demo_tab)"},{"path":"https://fbertran.github.io/SelectBoost.beta/reference/plot_compare_freq.html","id":null,"dir":"Reference","previous_headings":"","what":"Side-by-side selection-frequency heatmap — plot_compare_freq","title":"Side-by-side selection-frequency heatmap — plot_compare_freq","text":"Visual comparison bootstrap selection frequencies selector. Requires ggplot2.","code":""},{"path":"https://fbertran.github.io/SelectBoost.beta/reference/plot_compare_freq.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Side-by-side selection-frequency heatmap — plot_compare_freq","text":"","code":"plot_compare_freq(freq_tab)"},{"path":"https://fbertran.github.io/SelectBoost.beta/reference/plot_compare_freq.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Side-by-side selection-frequency heatmap — plot_compare_freq","text":"freq_tab Data frame returned compare_selectors_bootstrap().","code":""},{"path":"https://fbertran.github.io/SelectBoost.beta/reference/plot_compare_freq.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Side-by-side selection-frequency heatmap — plot_compare_freq","text":"ggplot object ggplot2 available; otherwise draws base R image.","code":""},{"path":"https://fbertran.github.io/SelectBoost.beta/reference/plot_compare_freq.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Side-by-side selection-frequency heatmap — plot_compare_freq","text":"","code":"freq_tab <- data.frame(   selector = rep(c(\"AIC\", \"BIC\"), each = 3),   variable = rep(paste0(\"x\", 1:3), times = 2),   freq = c(0.85, 0.2, 0.45, 0.75, 0.35, 0.3) ) plot_compare_freq(freq_tab)"},{"path":"https://fbertran.github.io/SelectBoost.beta/reference/sb_apply_selector_manual.html","id":null,"dir":"Reference","previous_headings":"","what":"Apply a selector to a collection of resampled designs — sb_apply_selector_manual","title":"Apply a selector to a collection of resampled designs — sb_apply_selector_manual","text":"Apply selector collection resampled designs","code":""},{"path":"https://fbertran.github.io/SelectBoost.beta/reference/sb_apply_selector_manual.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Apply a selector to a collection of resampled designs — sb_apply_selector_manual","text":"","code":"sb_apply_selector_manual(X_norm, resamples, Y, selector, ...)"},{"path":"https://fbertran.github.io/SelectBoost.beta/reference/sb_apply_selector_manual.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Apply a selector to a collection of resampled designs — sb_apply_selector_manual","text":"X_norm Normalised design matrix. resamples List matrices returned sb_resample_groups(). Y Numeric response. selector Variable-selection routine; function character string. ... Extra arguments passed selector.","code":""},{"path":"https://fbertran.github.io/SelectBoost.beta/reference/sb_apply_selector_manual.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Apply a selector to a collection of resampled designs — sb_apply_selector_manual","text":"numeric matrix coefficients one column per resample.","code":""},{"path":"https://fbertran.github.io/SelectBoost.beta/reference/sb_beta.html","id":null,"dir":"Reference","previous_headings":"","what":"SelectBoost for beta-regression models — sb_beta","title":"SelectBoost for beta-regression models — sb_beta","text":"sb_beta() orchestrates SelectBoost stages—normalisation, correlation analysis, grouping, correlated resampling, stability tallying—using beta-regression selectors provided package. can operate point-valued interval-valued responses automatically squeezes outcome (0, 1) unless instructed otherwise.","code":""},{"path":"https://fbertran.github.io/SelectBoost.beta/reference/sb_beta.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"SelectBoost for beta-regression models — sb_beta","text":"","code":"sb_beta(   X,   Y = NULL,   selector = betareg_step_aic,   corrfunc = \"cor\",   B = 100,   step.num = 0.1,   steps.seq = NULL,   version = c(\"glmnet\", \"lars\"),   squeeze = TRUE,   use.parallel = FALSE,   seed = NULL,   verbose = FALSE,   threshold = 1e-04,   interval = c(\"none\", \"uniform\", \"midpoint\"),   Y_low = NULL,   Y_high = NULL,   ... )"},{"path":"https://fbertran.github.io/SelectBoost.beta/reference/sb_beta.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"SelectBoost for beta-regression models — sb_beta","text":"X Numeric design matrix. Coerced .matrix() normalised via sb_normalize(). Y Numeric response vector. Values squeezed open unit interval standard SelectBoost transformation unless squeeze = FALSE. Optional interval bounds supplied. selector Selection routine. Defaults betareg_step_aic(). corrfunc Correlation function passed sb_compute_corr(). B Number replicates generate. step.num Step length automatically generated c0 grid. steps.seq Optional user-supplied grid absolute correlation thresholds. version Either \"glmnet\" (intercept first row) \"lars\". squeeze Logical; ensure response lies (0, 1). use.parallel Logical; enable parallel resampling selector fits supported current R session. seed Optional integer seed reproducibility. verbose Logical; emit progress messages. threshold Numeric tolerance considering coefficient selected. interval Interval-resampling mode: \"none\" reuses Y, whereas \"uniform\" \"midpoint\" draw pseudo-responses Y_low Y_high replicate. Y_low, Y_high Interval bounds [0, 1] paired rows X interval \"none\". ... Additional arguments forwarded selector.","code":""},{"path":"https://fbertran.github.io/SelectBoost.beta/reference/sb_beta.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"SelectBoost for beta-regression models — sb_beta","text":"Matrix selection frequencies one row per c0 level class \"sb_beta\". See Details recorded attributes.","code":""},{"path":"https://fbertran.github.io/SelectBoost.beta/reference/sb_beta.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"SelectBoost for beta-regression models — sb_beta","text":"returned object carries rich set attributes: \"c0.seq\" – grid absolute-correlation thresholds explored resampling. \"steps.seq\" – raw sequence () used construct grid. \"selector\" – selector identifier (function name expression). \"B\" – number resampled designs passed selector. \"interval\" – interval sampling mode (\"none\", \"uniform\", \"midpoint\"). \"resample_diagnostics\" – per-threshold data frames summary statistics cached correlated draws. attributes mirror historical SelectBoost beta implementation object can consumed existing plotting reporting utilities.","code":""},{"path":"https://fbertran.github.io/SelectBoost.beta/reference/sb_beta.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"SelectBoost for beta-regression models — sb_beta","text":"","code":"set.seed(42) sim <- simulation_DATA.beta(n = 80, p = 4, s = 2) res <- sb_beta(sim$X, sim$Y, B = 10) res #> SelectBoost beta selection frequencies #> Selector: betareg_step_aic #> Resamples per threshold: 10 #> Interval mode: none #> c0 grid: 1.000, 0.126, 0.113, 0.025, 0.000 #> Inner thresholds: 0.126, 0.113, 0.025 #>             x1  x2  x3  x4 phi|(Intercept) #> c0 = 1.000 1.0 1.0 0.0 0.0               1 #> c0 = 0.126 0.1 1.0 0.3 0.2               1 #> c0 = 0.113 0.3 0.0 0.4 0.2               1 #> c0 = 0.025 0.3 0.0 0.4 0.2               1 #> c0 = 0.000 0.2 0.1 0.2 0.4               1 #> attr(,\"c0.seq\") #> [1] 1.00000000 0.12616304 0.11291203 0.02454839 0.00000000 #> attr(,\"steps.seq\") #> [1] 0.12616304 0.11291203 0.02454839 #> attr(,\"B\") #> [1] 10 #> attr(,\"selector\") #> [1] \"betareg_step_aic\" #> attr(,\"resample_diagnostics\") #> attr(,\"resample_diagnostics\")$`c0 = 1.000` #> [1] group                   size                    regenerated             #> [4] cached                  mean_abs_corr_orig      mean_abs_corr_surrogate #> [7] mean_abs_corr_cross     #> <0 rows> (or 0-length row.names) #>  #> attr(,\"resample_diagnostics\")$`c0 = 0.126` #>      group size regenerated cached mean_abs_corr_orig mean_abs_corr_surrogate #> 1    x1,x4    2          10  FALSE          0.1275181               0.1195504 #> 2    x3,x4    2          10  FALSE          0.1261630               0.1249398 #> 3 x1,x3,x4    3          10  FALSE          0.1225041               0.1323147 #>   mean_abs_corr_cross #> 1          0.09746687 #> 2          0.07453088 #> 3          0.06767065 #>  #> attr(,\"resample_diagnostics\")$`c0 = 0.113` #>         group size regenerated cached mean_abs_corr_orig #> 1 x1,x2,x3,x4    4          10  FALSE         0.08541194 #> 2       x1,x2    2          10  FALSE         0.11291203 #> 3    x1,x3,x4    3           0   TRUE         0.12250411 #>   mean_abs_corr_surrogate mean_abs_corr_cross #> 1               0.1262968          0.08154752 #> 2               0.1424752          0.08312880 #> 3               0.1323147          0.06767065 #>  #> attr(,\"resample_diagnostics\")$`c0 = 0.025` #>         group size regenerated cached mean_abs_corr_orig #> 1 x1,x2,x3,x4    4           0   TRUE         0.08541194 #> 2    x1,x2,x4    3          10  FALSE         0.08832617 #> 3    x1,x3,x4    3           0   TRUE         0.12250411 #>   mean_abs_corr_surrogate mean_abs_corr_cross #> 1               0.1262968          0.08154752 #> 2               0.1083570          0.10442578 #> 3               0.1323147          0.06767065 #>  #> attr(,\"resample_diagnostics\")$`c0 = 0.000` #>         group size regenerated cached mean_abs_corr_orig #> 1 x1,x2,x3,x4    4           0   TRUE         0.08541194 #>   mean_abs_corr_surrogate mean_abs_corr_cross #> 1               0.1262968          0.08154752 #>  #> attr(,\"interval\") #> [1] \"none\""},{"path":"https://fbertran.github.io/SelectBoost.beta/reference/sb_beta_interval.html","id":null,"dir":"Reference","previous_headings":"","what":"SelectBoost workflow for interval responses — sb_beta_interval","title":"SelectBoost workflow for interval responses — sb_beta_interval","text":"sb_beta_interval() forwards sb_beta() activating interval sampling beta-regression SelectBoost runs can ingest lower/upper response bounds directly. mirrors fastboost_interval() reuses correlated resampling pipeline sb_beta().","code":""},{"path":"https://fbertran.github.io/SelectBoost.beta/reference/sb_beta_interval.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"SelectBoost workflow for interval responses — sb_beta_interval","text":"","code":"sb_beta_interval(   X,   Y_low,   Y_high,   selector = betareg_step_aic,   sample = c(\"uniform\", \"midpoint\"),   Y = NULL,   ... )"},{"path":"https://fbertran.github.io/SelectBoost.beta/reference/sb_beta_interval.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"SelectBoost workflow for interval responses — sb_beta_interval","text":"X Numeric design matrix. Coerced .matrix() normalised via sb_normalize(). Y_low, Y_high Interval bounds [0, 1] paired rows X interval \"none\". selector Selection routine. Defaults betareg_step_aic(). sample Interval sampling scheme passed interval argument sb_beta(). \"uniform\" draws pseudo-response uniformly within interval; \"midpoint\" always chooses midpoint. Y Optional point-valued response. Supply wish keep observed mean response still resample within Y_low/Y_high stability steps. ... Additional arguments forwarded selector.","code":""},{"path":"https://fbertran.github.io/SelectBoost.beta/reference/sb_beta_interval.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"SelectBoost workflow for interval responses — sb_beta_interval","text":"See sb_beta(). returned object carries \"sb_beta\"-class attributes describing correlation thresholds, resampling diagnostics, selector, number replicates.","code":""},{"path":"https://fbertran.github.io/SelectBoost.beta/reference/sb_beta_interval.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"SelectBoost workflow for interval responses — sb_beta_interval","text":"","code":"set.seed(1) sim <- simulation_DATA.beta(n = 120, p = 5, s = 2) y_low <- pmax(sim$Y - 0.05, 0) y_high <- pmin(sim$Y + 0.05, 1) interval_fit <- sb_beta_interval(   sim$X,   Y_low = y_low,   Y_high = y_high,   B = 30,   step.num = 0.4 ) attr(interval_fit, \"interval\") #> [1] \"uniform\""},{"path":"https://fbertran.github.io/SelectBoost.beta/reference/sb_beta_methods.html","id":null,"dir":"Reference","previous_headings":"","what":"User-friendly methods for sb_beta() results — sb_beta_methods","title":"User-friendly methods for sb_beta() results — sb_beta_methods","text":"S3 helpers make easier inspect visualise correlation-threshold grid returned sb_beta(). surface stored attributes, reshape selection frequencies tidy summaries, produce quick ggplot2 visualisations interactive use.","code":""},{"path":"https://fbertran.github.io/SelectBoost.beta/reference/sb_beta_methods.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"User-friendly methods for sb_beta() results — sb_beta_methods","text":"","code":"# S3 method for class 'sb_beta' print(x, digits = 3, ...)  # S3 method for class 'sb_beta' summary(object, ...)  # S3 method for class 'summary.sb_beta' print(x, digits = 3, n = 10, ...)  autoplot.sb_beta(object, variables = NULL, ...)"},{"path":"https://fbertran.github.io/SelectBoost.beta/reference/sb_beta_methods.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"User-friendly methods for sb_beta() results — sb_beta_methods","text":"x, object object class sb_beta. digits Number decimal places display printing. ... Additional arguments passed lower-level methods. n Number rows show summary table printing. variables Optional character vector variables retain plotted output.","code":""},{"path":"https://fbertran.github.io/SelectBoost.beta/reference/sb_beta_methods.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"User-friendly methods for sb_beta() results — sb_beta_methods","text":"summary.sb_beta() returns object class summary.sb_beta containing tidy data frame selection frequencies. plotting printing methods invoked side effects return input object invisibly.","code":""},{"path":"https://fbertran.github.io/SelectBoost.beta/reference/sb_beta_methods.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"User-friendly methods for sb_beta() results — sb_beta_methods","text":"","code":"set.seed(42) sim <- simulation_DATA.beta(n = 50, p = 4, s = 2) fit <- sb_beta(sim$X, sim$Y, B = 5, step.num = 0.5) print(fit) #> SelectBoost beta selection frequencies #> Selector: betareg_step_aic #> Resamples per threshold: 5 #> c0 grid: 1.000, 0.074, 0.000 #> Inner thresholds: 0.074 #>            x1  x2 x3  x4 #> c0 = 1.000  1 1.0  0 0.0 #> c0 = 0.074  0 0.2  0 0.0 #> c0 = 0.000  0 0.0  0 0.2 #> attr(,\"c0.seq\") #> [1] 1.00000000 0.07429122 0.00000000 #> attr(,\"steps.seq\") #> [1] 0.07429122 #> attr(,\"B\") #> [1] 5 #> attr(,\"selector\") #> [1] \"betareg_step_aic\" summary(fit) #> SelectBoost beta summary #> Selector: betareg_step_aic #> Resamples per threshold: 5 #> c0 grid: 1.000, 0.074, 0.000 #> Inner thresholds: 0.074 #> Top rows: #>        c0 variable frequency #> 1  1.0000       x1       1.0 #> 2  1.0000       x2       0.0 #> 3  1.0000       x3       0.0 #> 4  1.0000       x4       1.0 #> 5  0.0743       x1       0.2 #> 6  0.0743       x2       0.0 #> 7  0.0743       x3       0.0 #> 8  0.0743       x4       0.0 #> 9  0.0000       x1       0.0 #> 10 0.0000       x2       0.0 if (requireNamespace(\"ggplot2\", quietly = TRUE)) {   autoplot.sb_beta(fit) }"},{"path":"https://fbertran.github.io/SelectBoost.beta/reference/sb_normalize.html","id":null,"dir":"Reference","previous_headings":"","what":"Core helpers for SelectBoost-style beta regression — sb_normalize","title":"Core helpers for SelectBoost-style beta regression — sb_normalize","text":"helpers expose individual stages SelectBoost workflow beta-regression selectors can combined correlation-aware resampling directly SelectBoost.beta. normalise design matrix, derive correlation structures, form groups correlated predictors, generate Gaussian surrogates mimic observed dependency structure, apply user-provided selector resampled design.","code":""},{"path":"https://fbertran.github.io/SelectBoost.beta/reference/sb_normalize.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Core helpers for SelectBoost-style beta regression — sb_normalize","text":"","code":"sb_normalize(X, center = NULL, scale = NULL, eps = 1e-08)  sb_compute_corr(X, corrfunc = \"cor\")  sb_group_variables(corr_mat, c0)"},{"path":"https://fbertran.github.io/SelectBoost.beta/reference/sb_normalize.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Core helpers for SelectBoost-style beta regression — sb_normalize","text":"X Numeric matrix predictors. center Optional centering vector recycled number columns. Defaults column means X. scale Optional scaling vector recycled number columns. Defaults column-wise \\(\\ell_2\\) norms centred matrix. eps Small positive constant used normalising columns. corrfunc Function character string used compute pairwise associations. Defaults \"cor\". corr_mat Numeric matrix associations. c0 Threshold applied absolute correlations.","code":""},{"path":"https://fbertran.github.io/SelectBoost.beta/reference/sb_normalize.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Core helpers for SelectBoost-style beta regression — sb_normalize","text":"sb_normalize() returns centred, \\(\\ell_2\\)-scaled copy X. sb_compute_corr() returns association matrix. sb_group_variables() returns list integer vectors, one per variable, describing correlated group belongs .","code":""},{"path":"https://fbertran.github.io/SelectBoost.beta/reference/sb_normalize.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Core helpers for SelectBoost-style beta regression — sb_normalize","text":"","code":"sb_normalize(matrix(rnorm(20), 5)) #>            [,1]        [,2]       [,3]       [,4] #> [1,] -0.3151447 -0.01950574  0.2440691  0.3051062 #> [2,] -0.5242220 -0.54491941 -0.4022885  0.1989476 #> [3,]  0.2564657  0.76188516  0.7687388 -0.1054358 #> [4,] -0.1502584 -0.32535540 -0.2800823 -0.8225125 #> [5,]  0.7331595  0.12789540 -0.3304371  0.4238945 #> attr(,\"center\") #> [1] -0.362358849  0.324218844 -0.224694673  0.008141732 #> attr(,\"scale\") #> [1] 2.433633 1.431647 2.769985 2.826877"},{"path":"https://fbertran.github.io/SelectBoost.beta/reference/sb_resample_groups.html","id":null,"dir":"Reference","previous_headings":"","what":"Generate correlated design replicates for a set of groups — sb_resample_groups","title":"Generate correlated design replicates for a set of groups — sb_resample_groups","text":"Generate correlated design replicates set groups","code":""},{"path":"https://fbertran.github.io/SelectBoost.beta/reference/sb_resample_groups.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Generate correlated design replicates for a set of groups — sb_resample_groups","text":"","code":"sb_resample_groups(   X_norm,   groups,   B = 100,   jitter = 1e-06,   seed = NULL,   use.parallel = FALSE,   cache = NULL )"},{"path":"https://fbertran.github.io/SelectBoost.beta/reference/sb_resample_groups.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Generate correlated design replicates for a set of groups — sb_resample_groups","text":"X_norm Normalised design matrix. groups Correlation structure. Either list returned sb_group_variables() vector group labels matching columns X_norm. B Number replicates generate. jitter Numeric value added covariance diagonals stability. seed Optional integer seed reproducibility. use.parallel Logical; TRUE, compute resampled designs using parallel backend available. cache Optional environment named list used cache previously generated surrogates. Passing cache across calls reuses draws identical groups.","code":""},{"path":"https://fbertran.github.io/SelectBoost.beta/reference/sb_resample_groups.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Generate correlated design replicates for a set of groups — sb_resample_groups","text":"object class sb_resamples, .e. list length B whose elements resampled design matrices. object exposes per-group diagnostics \"diagnostics\" attribute returns cache via \"cache\" attribute reuse.","code":""},{"path":"https://fbertran.github.io/SelectBoost.beta/reference/sb_selection_frequency.html","id":null,"dir":"Reference","previous_headings":"","what":"Compute selection frequencies from coefficient paths — sb_selection_frequency","title":"Compute selection frequencies from coefficient paths — sb_selection_frequency","text":"Compute selection frequencies coefficient paths","code":""},{"path":"https://fbertran.github.io/SelectBoost.beta/reference/sb_selection_frequency.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Compute selection frequencies from coefficient paths — sb_selection_frequency","text":"","code":"sb_selection_frequency(   coef_matrix,   version = c(\"glmnet\", \"lars\"),   threshold = 1e-04 )"},{"path":"https://fbertran.github.io/SelectBoost.beta/reference/sb_selection_frequency.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Compute selection frequencies from coefficient paths — sb_selection_frequency","text":"coef_matrix Matrix produced sb_apply_selector_manual(). version Either \"glmnet\" (first row intercept) \"lars\". threshold Coefficients absolute value threshold treated zero.","code":""},{"path":"https://fbertran.github.io/SelectBoost.beta/reference/sb_selection_frequency.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Compute selection frequencies from coefficient paths — sb_selection_frequency","text":"Numeric vector selection frequencies.","code":""},{"path":"https://fbertran.github.io/SelectBoost.beta/reference/simulation_DATA.beta.html","id":null,"dir":"Reference","previous_headings":"","what":"Simulate interval Beta-regression data (flexible) — simulation_DATA.beta","title":"Simulate interval Beta-regression data (flexible) — simulation_DATA.beta","text":"Simulate interval Beta-regression data (flexible)","code":""},{"path":"https://fbertran.github.io/SelectBoost.beta/reference/simulation_DATA.beta.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Simulate interval Beta-regression data (flexible) — simulation_DATA.beta","text":"","code":"simulation_DATA.beta(   n,   p,   s = min(5L, p),   beta_size = 1,   a0 = 0,   X_dist = c(\"gaussian\", \"t\", \"bernoulli\"),   corr = c(\"indep\", \"ar1\", \"block\"),   rho = 0,   block_size = 5L,   df = 5,   prob = 0.5,   active_idx = NULL,   phi = 20,   mechanism = c(\"jitter\", \"quantile\", \"mixed\"),   mix_prob = 0.5,   delta = 0.05,   delta_low = NULL,   delta_high = NULL,   alpha = 0.1,   alpha_low = NULL,   alpha_high = NULL,   na_rate = 0,   na_side = c(\"random\", \"left\", \"right\"),   centerX = FALSE,   scaleX = FALSE,   seed = NULL )"},{"path":"https://fbertran.github.io/SelectBoost.beta/reference/simulation_DATA.beta.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Simulate interval Beta-regression data (flexible) — simulation_DATA.beta","text":"n, p Sample size number predictors. s Number active (nonzero) coefficients. beta_size Scalar (alternating ±) numeric vector length greater equal s. a0 Intercept (logit scale). X_dist Distribution X: \"gaussian\", \"t\", \"bernoulli\". corr Correlation structure: \"indep\", \"ar1\", \"block\". rho AR(1) correlation within-block correlation. block_size Block size corr = \"block\" (default 5). df Degrees freedom X_dist = \"t\" (default 5). prob Success prob X_dist = \"bernoulli\" (default 0.5). active_idx Optional integer vector active feature indices (length s). NULL, uses 1:s. phi Precision parameter: scalar, length-n vector, function (mu, X) -> length-n. mechanism Interval mechanism per row: \"jitter\", \"quantile\", \"mixed\". mix_prob Probability jitter mechanism = \"mixed\". delta Symmetric jitter half-width (scalar / vector / function). delta_low, delta_high Asymmetric jitter widths (override delta set). alpha Miscoverage quantile intervals (scalar / vector / function). alpha_low, alpha_high Asymmetric miscoverage (override alpha set). na_rate Fraction rows missing bound (default 0). na_side bound drop: \"left\", \"right\", \"random\". centerX, scaleX Whether center/scale X returning. seed RNG seed.","code":""},{"path":"https://fbertran.github.io/SelectBoost.beta/reference/simulation_DATA.beta.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Simulate interval Beta-regression data (flexible) — simulation_DATA.beta","text":"list X, Y, Y_low, Y_high, mu, beta, a0, phi, info, settings.","code":""},{"path":"https://fbertran.github.io/SelectBoost.beta/news/index.html","id":"selectboostbeta-045","dir":"Changelog","previous_headings":"","what":"SelectBoost.beta 0.4.5","title":"SelectBoost.beta 0.4.5","text":"Added pseudo-code vignette, refreshed README workflow details, expanded unit test suite new helpers. Fixed code descriptions get rid notes CRAN checks. Enabled optional parallel resampling sb_beta()/sb_resample_groups() via future.apply, added S3 print/summary/autoplot helpers sb_beta results, documented new behaviour README. Extended stepwise beta selectors handle observation weights precision-submodel search, exposing precision coefficients returned paths. Added reproducible resampling caches quality diagnostics sb_resample_groups()/sb_beta(), including interval-response support reuses pseudo-responses across correlation thresholds. Documented interval workflows prominently adding sb_beta_interval(), expanding README/CRAN vignette guidance selector choice interval stability, clarifying comparison-helper outputs response squeezing.","code":""},{"path":"https://fbertran.github.io/SelectBoost.beta/news/index.html","id":"selectboostbeta-044","dir":"Changelog","previous_headings":"","what":"SelectBoost.beta 0.4.4","title":"SelectBoost.beta 0.4.4","text":"Add NEWS.md documenting development history.","code":""},{"path":"https://fbertran.github.io/SelectBoost.beta/news/index.html","id":"selectboostbeta-043","dir":"Changelog","previous_headings":"","what":"SelectBoost.beta 0.4.3","title":"SelectBoost.beta 0.4.3","text":"Added sb_beta() run full SelectBoost correlated-resampling loop beta-regression selectors, plus vignette illustrating workflow. Added vignette section demonstrating extended simulator interval selection.","code":""},{"path":"https://fbertran.github.io/SelectBoost.beta/news/index.html","id":"selectboostbeta-042","dir":"Changelog","previous_headings":"","what":"SelectBoost.beta 0.4.2","title":"SelectBoost.beta 0.4.2","text":"interval = \"jitter\" (symmetric) \"quantile\" (Beta quantile intervals). Works fastboost_interval(); added small vignette unit test. Supports mixed mechanisms (row-wise jitter vs quantile), asymmetric jitter widths (delta_low/delta_high), asymmetric quantile coverage (alpha_low/alpha_high), covariate-driven parameters (accept functions (mu, X)), optional missing bounds per row (na_rate, na_side).","code":""},{"path":"https://fbertran.github.io/SelectBoost.beta/news/index.html","id":"selectboostbeta-041","dir":"Changelog","previous_headings":"","what":"SelectBoost.beta 0.4.1","title":"SelectBoost.beta 0.4.1","text":"compare_selectors_single(), compare_selectors_bootstrap() run selectors (AIC/BIC/AICc, GAMLSS LASSO/ENet*, GLMNET) compute selection frequencies. plot_compare_coeff(), plot_compare_freq() heatmaps compare selectors side side. Vignette expanded include simulated data two real-ish datasets scaling (0,1). ENet requires gamlss.lasso installed.","code":""},{"path":"https://fbertran.github.io/SelectBoost.beta/news/index.html","id":"selectboostbeta-040","dir":"Changelog","previous_headings":"","what":"SelectBoost.beta 0.4.0","title":"SelectBoost.beta 0.4.0","text":"Stepwise AIC, BIC, AICc wrappers around betareg. GAMLSS LASSO (gamlss::ri) optional Elastic-Net (gamlss.lasso::gnet). Pure glmnet (IRLS + weighted Gaussian ENet) optional prestandardize. fastboost_interval() prototype interval responses. First vignette + roxygenized docs.","code":""}]
